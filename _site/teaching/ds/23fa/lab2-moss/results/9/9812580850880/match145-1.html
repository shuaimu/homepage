<HTML>
<HEAD>
<TITLE>./github-lab2/dslabs-cpp-bnithish/src/kv/server.cc</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
./github-lab2/dslabs-cpp-PranavDani/src/kv/server.cc<p><PRE>
#include "../deptran/__dep__.h"
#include "server.h"
#include "../deptran/raft/server.h"
#include "client.h"

namespace janus {

  static int volatile x1 =
    MarshallDeputy::RegInitializer(MarshallDeputy::CMD_MULTI_STRING,
      []() -&gt; Marshallable* {
        return new MultiStringMarshallable;
      });

  int64_t KvServer::GetNextOpId() {
    verify(sp_log_svr_);
    int64_t ret = sp_log_svr_-&gt;site_id_;
    ret = ret &lt;&lt; 32;
    ret = ret + op_id_cnt_++;
    return ret;
  }

  int KvServer::Put(const uint64_t& oid,
    const string& k,
    const string& v) {

    // Your are recommended to use MultiStringMarshallable as the format
    // for the log entries. Here is an example how you can use it.

    auto s = make_shared&lt;MultiStringMarshallable&gt;();
    s-&gt;data_.push_back(to_string(oid));
    s-&gt;data_.push_back("put");
    s-&gt;data_.push_back(k);
    s-&gt;data_.push_back(v);


    /* your code here */

    uint64_t index = -1;
    uint64_t term = -1;

    std::shared_ptr&lt;Marshallable&gt; cmd = s;

    Log_info("Put KV server %d with %d oid %s k, %s v", sp_log_svr_-&gt;loc_id_, oid, k.c_str(), v.c_str());
    bool isLeader = GetRaftServer().Start(cmd, &index, &term);

    if (isLeader) {
      auto now = std::chrono::high_resolution_clock::now();
      std::chrono::high_resolution_clock::time_point timeout = std::chrono::system_clock::now() + std::chrono::milliseconds(2000);

      while (now &lt; timeout) {
        now = std::chrono::high_resolution_clock::now();

        if (commitMap[s-&gt;data_[0].c_str()]) {

          Log_info("Put value successful for server %d with key %s is %s", sp_log_svr_-&gt;loc_id_, k.c_str(), kv[k].c_str());

          return KV_SUCCESS;
        }

        Coroutine::Sleep(1000);
      }

      return KV_TIMEOUT;
    }
    else {
<A NAME="0"></A><FONT color = #FF0000><A HREF="match145-0.html#0" TARGET="0"><IMG SRC="../../../bitmaps/tm_0_3.gif" ALT="other" BORDER="0" ALIGN=left></A>

      Log_info("Server %d is not leader", sp_log_svr_-&gt;loc_id_);
      return KV_NOTLEADER;
    }

  }

  int KvServer::Append(const uint64_t& oid,
    const string& k,
    const string& v) {
    /* your code here */

    auto s = make_shared&lt;MultiStringMarshallable&gt;();
</FONT>    s-&gt;data_.push_back(to_string(oid));
    s-&gt;data_.push_back("append");
    s-&gt;data_.push_back(k);
    s-&gt;data_.push_back(v);

    uint64_t index = -1;
    uint64_t term = -1;

    std::shared_ptr&lt;Marshallable&gt; cmd = s;


    Log_info("Append in KV server %d with %d oid %s k, %s v", sp_log_svr_-&gt;loc_id_, oid, k.c_str(), v.c_str());
    bool isLeader = GetRaftServer().Start(cmd, &index, &term);

    if (isLeader) {
      auto now = std::chrono::high_resolution_clock::now();
      std::chrono::high_resolution_clock::time_point timeout = std::chrono::system_clock::now() + std::chrono::milliseconds(2000);

      while (now &lt; timeout) {
        now = std::chrono::high_resolution_clock::now();

        if (commitMap[s-&gt;data_[0].c_str()]) {

          Log_info("Append successful %d op %d key and %d value, committed by server %d", oid, k, v, sp_log_svr_-&gt;loc_id_);
          return KV_SUCCESS;
        }

        Coroutine::Sleep(1000);
      }

      return KV_TIMEOUT;
    }
    else {
<A NAME="1"></A><FONT color = #00FF00><A HREF="match145-0.html#1" TARGET="0"><IMG SRC="../../../bitmaps/tm_1_2.gif" ALT="other" BORDER="0" ALIGN=left></A>

      Log_info("Server %d is not leader", sp_log_svr_-&gt;loc_id_);
      return KV_NOTLEADER;
    }
  }

  int KvServer::Get(const uint64_t& oid,
    const string& k,
    string* v) {
    /* your code here */

    auto s = make_shared&lt;MultiStringMarshallable&gt;();
</FONT>    s-&gt;data_.push_back(to_string(oid));
    s-&gt;data_.push_back("get");
    s-&gt;data_.push_back(k);
    // s-&gt;data_.push_back(*v);


    uint64_t index = -1;
    uint64_t term = -1;

    std::shared_ptr&lt;Marshallable&gt; cmd = s;


    Log_info("Get in KV server %d with %d oid %s k", sp_log_svr_-&gt;loc_id_, oid, k.c_str());
    bool isLeader = GetRaftServer().Start(cmd, &index, &term);

    if (isLeader) {
      // Log_info("%d IsLeader for put", sp_log_svr_-&gt;loc_id_);

      auto now = std::chrono::high_resolution_clock::now();
      std::chrono::high_resolution_clock::time_point timeout = std::chrono::system_clock::now() + std::chrono::milliseconds(2000);

      while (now &lt; timeout) {
        now = std::chrono::high_resolution_clock::now();

        if (commitMap[s-&gt;data_[0].c_str()]) {

          mtx.lock();
          Log_info("Get value for key %s is %s", k.c_str(), kv[k].c_str());

          *v = kv[k];

          mtx.unlock();
          return KV_SUCCESS;
        }

        Coroutine::Sleep(1000);
      }

      return KV_TIMEOUT;
    }
    else {
      Log_info("Server %d is not leader", sp_log_svr_-&gt;loc_id_);
      return KV_NOTLEADER;
    }

    // return KV_SUCCESS;
  }

  void KvServer::OnNextCommand(Marshallable& m) {
    /* your code here */

    // Coroutine::CreateRun([this, &m]() {
    auto v = (MultiStringMarshallable*)(&m);
    Log_info("OnNext command at KVServer %d with %s oid %s k, %s type", sp_log_svr_-&gt;loc_id_, v-&gt;data_[0].c_str(), v-&gt;data_[2].c_str(), v-&gt;data_[1].c_str());


    string oid = v-&gt;data_[0];
    string type = v-&gt;data_[1];
    string key = v-&gt;data_[2];

    if (commitMap[oid]) {
      mtx.unlock();
      Log_info("Already committed");
      return;
    }



    mtx.lock();
    if (type == "put") {
      string value = v-&gt;data_[3];
      kv[key] = value;
      Log_info("Value for key %s is %s", key.c_str(), kv[key].c_str());
    }
    else if (type == "append") {
      string value = v-&gt;data_[3];
      kv[key] += value;
      Log_info("New value for key %s is %s", key.c_str(), kv[key].c_str());
    }
    else if (type == "get") {
    }

    commitMap[oid] = true;
    mtx.unlock();

    // });

  }

  shared_ptr&lt;KvClient&gt; KvServer::CreateClient() {
    /* don't change this function */
    auto cli = make_shared&lt;KvClient&gt;();
    verify(commo_ != nullptr);
    cli-&gt;commo_ = commo_;
    uint32_t id = sp_log_svr_-&gt;site_id_;
    id = id &lt;&lt; 16;
    cli-&gt;cli_id_ = id + cli_cnt_++;
    return cli;
  }

} // namespace janus;</PRE>
</PRE>
</BODY>
</HTML>
