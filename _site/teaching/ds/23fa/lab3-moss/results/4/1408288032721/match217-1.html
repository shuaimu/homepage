<HTML>
<HEAD>
<TITLE>/root/ds-labs-ta/github-lab3/shuai-teaching/dslabs-cpp-PranavDani/src/shardmaster/service.h</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
/root/ds-labs-ta/github-lab3/shuai-teaching/dslabs-cpp-kanavtalwar/src/shardmaster/service.h<p><PRE>

#pragma once

#include "../deptran/__dep__.h"
#include "../deptran/raft/server.h"

class ShardConfig {
 public:
  int32_t number{0};
  map&lt;uint32_t, uint32_t&gt; shard_group_map_{{1,0},{2,0},{3,0},{4,0},{5,0},{6,0},{7,0},{8,0},{9,0},{10,0}};
  map&lt;uint32_t, vector&lt;uint32_t&gt;&gt; group_servers_map_{};
  // Lab Shard: you can add functions to this class but do not add/remove member variables
};

inline Marshal& operator&gt;&gt;(Marshal& m, ShardConfig& rhs) {
  m &gt;&gt; rhs.number &gt;&gt; rhs.shard_group_map_ &gt;&gt; rhs.group_servers_map_;
  return m;
}

<A NAME="1"></A><FONT color = #00FF00><A HREF="match217-0.html#1" TARGET="0"><IMG SRC="../../../bitmaps/tm_1_5.gif" ALT="other" BORDER="0" ALIGN=left></A>

inline Marshal& operator&lt;&lt;(Marshal& m, const ShardConfig& rhs) {
  m &lt;&lt; rhs.number &lt;&lt; rhs.shard_group_map_ &lt;&lt; rhs.group_servers_map_;
  return m;
}

#include "shardmaster_rpc.h"

namespace janus {
class ShardMasterMarshallable : public Marshallable {
 public:
  ShardMasterMarshallable() : Marshallable(MarshallDeputy::CMD_SNAPSHOT) {}
</FONT>  string opid;
  string operation;
  int64_t configCount;
  map&lt;uint32_t, std::vector&lt;uint32_t&gt;&gt; mapOfGid;
  vector&lt;uint32_t&gt; gids;
  uint32_t gid;
  int32_t shard;
  Marshal& ToMarshal(Marshal& m) const override {
    m &lt;&lt; opid;
    m &lt;&lt; operation;
    m &lt;&lt; configCount;
    int32_t sz = mapOfGid.size();
    m &lt;&lt; sz;
    for(auto& entry : mapOfGid) {
      m &lt;&lt; entry.first;
      m &lt;&lt; entry.second;
    }
    int32_t sz2 = gids.size();
    m &lt;&lt; sz2;
    for(auto& entry : gids) {
      m &lt;&lt; entry;
    }
    m &lt;&lt; gid;
    m &lt;&lt; shard;
    return m;
  }
  Marshal& FromMarshal(Marshal& m) override {
    int32_t size1;
    int32_t size2;
    m &gt;&gt; opid;
    m &gt;&gt; operation;
    m &gt;&gt; configCount;
    m &gt;&gt; size1;
    for(int i =0;i&lt;size1;i++) {
      uint32_t key;
      std::vector&lt;uint32_t&gt; gids;
      m&gt;&gt;key;
      m&gt;&gt;gids;
      mapOfGid[key] = gids;
    }
    m &gt;&gt; size2;
    for(int i =0;i&lt;size2;i++) {
      uint32_t gid;
      m&gt;&gt;gid;
      gids.push_back(gid);
    }
<A NAME="0"></A><FONT color = #FF0000><A HREF="match217-0.html#0" TARGET="0"><IMG SRC="../../../bitmaps/tm_0_6.gif" ALT="other" BORDER="0" ALIGN=left></A>

    m&gt;&gt;gid;
    m&gt;&gt;shard;
    return m;
  }
};
// class TxLogServer;
// class KvServer;
class ShardMasterClient;
class ShardMasterServiceImpl : public ShardMasterService {
 public:
  shared_ptr&lt;TxLogServer&gt; sp_log_svr_{}; 
  const uint64_t SM_TIMEOUT = 10000000; // 10s
  map&lt;uint32_t, ShardConfig&gt; configs_{}; 
  map&lt;string, int&gt; operationToStatusMapping;
</FONT>  int64_t op_id_cnt_ = 0; 
  int64_t configCount = 0;
  // add your own variables here if needed 

  // add your own functions here if needed 
  std::map&lt;uint32_t, uint32_t&gt; BalanceMap(std::map&lt;uint32_t, std::vector&lt;uint32_t&gt;&gt; &myMap, std::map&lt;uint32_t, uint32_t&gt;& shardGroupMap);
  void printMap(map&lt;uint32_t, std::vector&lt;uint32_t&gt;&gt; myGidServersMap);
  int64_t GetNextOpId(); 

  // do not change anything below
  RaftServer& GetRaftServer() {
    auto p = dynamic_pointer_cast&lt;RaftServer&gt;(sp_log_svr_);
    verify(p != nullptr);
    return *p;
  }
  ShardMasterServiceImpl() {}
  virtual void Join(const std::map&lt;uint32_t, std::vector&lt;uint32_t&gt;&gt; &gid_server_map, uint32_t *ret, rrr::DeferredReply *defer) override;
  virtual void Leave(const std::vector&lt;uint32_t&gt;& gids, uint32_t* ret, rrr::DeferredReply* defer) override;
  virtual void Move(const int32_t& shard, const uint32_t& gid, uint32_t* ret, rrr::DeferredReply* defer) override;
  virtual void Query(const int32_t& config_no, uint32_t* ret, ShardConfig* config, rrr::DeferredReply* defer) override;
  void OnNextCommand(Marshallable& m);
  shared_ptr&lt;ShardMasterClient&gt; CreateClient();
};

} // namespace janus
</PRE>
</PRE>
</BODY>
</HTML>
