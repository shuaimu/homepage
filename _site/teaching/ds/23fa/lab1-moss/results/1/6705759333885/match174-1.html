<HTML>
<HEAD>
<TITLE>./github-lab1/dslabs-cpp-Aditiii/src/deptran/raft/server.cc</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
./github-lab1/dslabs-cpp-JayaramKrovvidi/src/deptran/raft/server.cc<p><PRE>


#include "server.h"
// #include "paxos_worker.h"
#include "exec.h"
#include "frame.h"
#include "coordinator.h"
#include "../classic/tpc_command.h"


namespace janus {

RaftServer::RaftServer(Frame * frame) {
  frame_ = frame ;
  /* Your code here for server initialization. Note that this function is 
     called in a different OS thread. Be careful about thread safety if 
     you want to initialize variables here. */

}

RaftServer::~RaftServer() {
  /* Your code here for server teardown */

}

void RaftServer::Setup() {
  /* Your code here for server setup. Due to the asynchronous nature of the 
     framework, this function could be called after a RPC handler is triggered. 
     Your code should be aware of that. This function is always called in the 
     same OS thread as the RPC handlers. */
  Coroutine::Sleep(1000000);
  currentTerm = 0, currentLeader = -1, votedFor = -1;
  commitLength = 0, currentRole = FOLLOWER;
  sentLength = {}, ackLength = {};
  votesReceived = {};
  log = {};
  resetElectionTimer();
}

bool RaftServer::Start(shared_ptr&lt;Marshallable&gt; &cmd, uint64_t *index, uint64_t *term) {
  /* Your code here. This function can be called from another OS thread. */
  if(currentRole != LEADER) return false;

  std::lock_guard&lt;std::recursive_mutex&gt; lock(mtx_);
  *index = log.size()+1;
  *term = currentTerm;
  log.push_back({*term, *index, cmd});
  Log_info("Node %d :: Received command %d for term %d", site_id_, *index, *term);
  return true;
}

void RaftServer::GetState(bool *is_leader, uint64_t *term) {
  /* Your code here. This function can be called from another OS thread. */
  *is_leader = (currentRole == LEADER);
  *term = currentTerm;
}

void RaftServer::SyncRpcExample() {
  /* This is an example of synchronous RPC using coroutine; feel free to 
     modify this function to dispatch/receive your own messages. 
     You can refer to the other function examples in commo.h/cc on how 
     to send/recv a Marshallable object over RPC. */
  Coroutine::CreateRun([this](){
    string res;
    auto event = commo()-&gt;SendString(0, /* partition id is always 0 for lab1 */
                                     0, "hello", &res);
    event-&gt;Wait(1000000); //timeout after 1000000us=1s
    if (event-&gt;status_ == Event::TIMEOUT) {
      Log_info("timeout happens");
    } else {
      Log_info("rpc response is: %s", res.c_str()); 
    }
  });
}

void RaftServer :: startElectionTimer() {

  isElectionActive = true;
  isElectionTimerActive = true;

  electionRunner = Coroutine::CreateRun([this]() {
    while(isElectionActive && isElectionTimerActive) {
      isElectionTimerActive = false;
      electionTimeout = 500 + (rand() % 500);
      Coroutine::Sleep(electionTimeout*1000);
    }
    if(isElectionActive && !isElectionTimerActive) {
      while(IsDisconnected()) Coroutine::Sleep(10000);
      startElection();
    } 
    electionRunner = nullptr;
  });
}

void RaftServer :: resetElectionTimer () {
  isElectionTimerActive = true;
  if(electionRunner == nullptr || electionRunner-&gt;Finished())
    startElectionTimer();
}

void RaftServer :: cancelElection() {
  isElectionActive = false;
  isElectionTimerActive = false;
}

void RaftServer :: startElection() {
  currentTerm++; currentRole = CANDIDATE;
  votedFor = site_id_; votesReceived = {};
  votesReceived.insert(site_id_);
  uint64_t lastTerm = log.size() &gt; 0 ? log[log.size() - 1].term : 0;

  Log_info("Node %d :: Starting Election for Term: %d", site_id_, currentTerm.load());

  Coroutine::CreateRun([this, lastTerm]() {
    numVoteResponses = 1;
    for (auto &node : commo() -&gt; rpc_par_proxies_[0]) {
      siteid_t followerId = node.first;
      if (followerId != site_id_) {
        uint64_t followerTerm;
        bool_t voteGranted;
        auto event = commo()-&gt;SendRequestVote(0, followerId, site_id_, currentTerm, log.size(), lastTerm, &followerTerm, &voteGranted);
        event-&gt;Wait(100000);
        numVoteResponses++;
        if(event-&gt;status_ == Event::TIMEOUT) {
          Log_info("Node %d :: Didn't receive vote from %d", site_id_, followerId);
        } else {
          collectVotes(followerId, followerTerm, voteGranted);
        }
        if((numVoteResponses - votesReceived.size()) &gt; commo() -&gt; rpc_par_proxies_[0].size() / 2) {
          Log_info("Node %d :: Restarting Election Timer :: Enough votes not gained", site_id_);
          resetElectionTimer();
        }
      }
    }
  });
}

tuple&lt;uint64_t, bool&gt; RaftServer :: onVoteRequestReceived(siteid_t candidateId, uint64_t candidateTerm, size_t candidateLogLength, uint64_t candidateLastTerm) {

  if(candidateTerm &gt; currentTerm) {
    currentTerm = candidateTerm;
    currentRole = FOLLOWER;
    votedFor = -1;
  }
  uint64_t lastTerm = log.size() &gt; 0 ? log[log.size() - 1].term : 0;
  bool logOk = (candidateLastTerm &gt; lastTerm) || (candidateLastTerm == lastTerm && candidateLogLength &gt;= log.size());

  if(candidateTerm == currentTerm && logOk && (votedFor == -1 || votedFor == candidateId)) {
    votedFor = candidateId;
    return {currentTerm, true};
  } else {
    return {currentTerm, false};
  }
}

void RaftServer :: collectVotes(siteid_t voterId, uint64_t voterTerm, bool_t voteGranted) {
  
  if(!isElectionActive) return;

  if(currentRole == CANDIDATE && voterTerm == currentTerm && voteGranted) {
    votesReceived.insert(voterId);
    if(votesReceived.size() &gt; commo()-&gt;rpc_par_proxies_[0].size() / 2) {
      Log_info("Node %d :: Elected as leader for term %d", site_id_, currentTerm.load());
      currentRole = LEADER;
      currentLeader = site_id_;
      cancelElection();
      sendHeartBeats();
    }
  } else if (voterTerm &gt; currentTerm) {
    currentTerm = voterTerm;
    currentRole = FOLLOWER;
    votedFor = -1;
    resetElectionTimer();
  }

}

void RaftServer :: sendHeartBeats() {

  if(currentRole != LEADER) return;

  Coroutine::CreateRun([this]() {
    while(currentRole == LEADER) {
      for (auto &node : commo() -&gt; rpc_par_proxies_[0]) {
        siteid_t followerId = node.first;
        if (followerId != site_id_) {
          replicateLog(followerId);
        }
      }
      Coroutine::Sleep(HEARTBEAT_INTERVAL_MS * 1000);
    }
  });
}

void RaftServer :: replicateLog(siteid_t followerId) {
  size_t prefixLength = sentLength[followerId];
  vector&lt;LogEntry&gt; logsToSend = {};
  for(size_t i = prefixLength; i &lt; log.size(); i++) {
    logsToSend.push_back(log[i]);
  }
  uint64_t prefixTerm = prefixLength &gt; 0 ? log[prefixLength - 1].term : 0;
  sendAppendEntriesRPC(followerId, currentTerm, prefixLength, prefixTerm, commitLength, logsToSend);
}

void RaftServer :: sendAppendEntriesRPC(siteid_t followerId, uint64_t leaderTerm, size_t prefixLength, uint64_t prefixTerm, size_t leaderCommit, vector&lt;LogEntry&gt; &leaderLog) {
  Coroutine::CreateRun([this, followerId, leaderTerm, prefixLength, prefixTerm, leaderCommit, leaderLog]() {
    uint64_t followerTerm, acknowledge;
    bool_t appendSuccess;
    vector&lt;size_t&gt; logIndexes = {};
    vector&lt;uint64_t&gt; logTerms = {};
    vector&lt;janus::MarshallDeputy&gt; logCmds = {};
    for(auto &entry : leaderLog) {
      logIndexes.push_back(entry.index);
      logTerms.push_back(entry.term);
      MarshallDeputy md(entry.cmd);
      logCmds.push_back(md);
    }

<A NAME="1"></A><FONT color = #00FF00><A HREF="match174-0.html#1" TARGET="0"><IMG SRC="../../../bitmaps/tm_1_1.gif" ALT="other" BORDER="0" ALIGN=left></A>

    auto event = commo()-&gt;SendAppendLogs(0, followerId, site_id_, leaderTerm, prefixLength, prefixTerm, leaderCommit,
                                    logIndexes, logTerms, logCmds, &followerTerm, &acknowledge, &appendSuccess);
    event-&gt;Wait(100000);
</FONT>    if(event-&gt;status_ == Event::TIMEOUT) {
      Log_info("Node %d :: Didn't receive ack from %d, for index: %d and length: %d", site_id_, followerId, prefixLength, logIndexes.size());
    } else {
      onReceiveAck(followerId, followerTerm, acknowledge, appendSuccess);
    }
  });
}

tuple&lt;uint64_t, size_t, bool&gt; RaftServer :: onReceiveLog(siteid_t leaderId, uint64_t leaderTerm, size_t prefixLength, uint64_t prefixTerm, size_t leaderCommit, vector&lt;RaftServer :: LogEntry&gt; &leaderLog) {
  
  if(leaderTerm &gt; currentTerm) {
    currentTerm = leaderTerm;
    votedFor = -1;
  }

  if(leaderTerm == currentTerm) {
    currentRole = FOLLOWER;
    currentLeader = leaderId;
    resetElectionTimer();
  }

  std::lock_guard&lt;std::recursive_mutex&gt; lock(mtx_);

  bool logOk = (log.size() &gt;= prefixLength) && (prefixLength == 0 || log[prefixLength - 1].term == prefixTerm);

  if(leaderTerm == currentTerm && logOk) {

    if(leaderLog.size() &gt; 0 && log.size() &gt; prefixLength) {
      int commonIndex = min(log.size(), prefixLength + leaderLog.size()) - 1;
      if(log[commonIndex].term != leaderLog[commonIndex - prefixLength].term) {
        log.erase(log.begin() + prefixLength, log.end());
      }
    }

    if(prefixLength + leaderLog.size() &gt; log.size()) {
      for(int i = 0; i &lt; leaderLog.size(); i++) {
        if(i + prefixLength &gt;= log.size()) {
          log.push_back(leaderLog[i]);
        } else if(log[i + prefixLength].term != leaderLog[i].term) {
          log.erase(log.begin() + i + prefixLength, log.end());
          log.push_back(leaderLog[i]);
        }
      }
    }

    if(leaderCommit &gt; commitLength) {
      Log_info("Node %d :: Committing %d log entries from index %d to %d", site_id_, leaderCommit - commitLength.load(), commitLength.load(), leaderCommit);
      for(int i = commitLength; i &lt; leaderCommit; ++i) {
        app_next_(*(log[i].cmd));
      }
      commitLength = leaderCommit;
    }

    size_t acknowledge = prefixLength + leaderLog.size();
    return {currentTerm, acknowledge, true};
  } else {
    return {currentTerm, 0, false};
  }
}

void RaftServer :: onReceiveAck(siteid_t followerId, uint64_t followerTerm, size_t ack, bool_t success) {

  std::lock_guard&lt;std::recursive_mutex&gt; lock(mtx_);
  if(followerTerm == currentTerm && currentRole == LEADER) {
<A NAME="0"></A><FONT color = #FF0000><A HREF="match174-0.html#0" TARGET="0"><IMG SRC="../../../bitmaps/tm_0_1.gif" ALT="other" BORDER="0" ALIGN=left></A>

    if(success && ack &gt;= ackLength[followerId]) {
      sentLength[followerId] = ack;
      ackLength[followerId] = ack;
      commitEntries();
    } else if(sentLength[followerId] &gt; 0) {
      sentLength[followerId]--;
    }
  } else if (followerTerm &gt; currentTerm) {
    currentTerm = followerTerm;
</FONT>    currentRole = FOLLOWER;
    votedFor = -1;
    resetElectionTimer();
  }
}

void RaftServer :: commitEntries() {
  size_t tempCommitLength = commitLength;
  while(tempCommitLength &lt; log.size() && log[tempCommitLength].term &lt; currentTerm) tempCommitLength++;
  if(tempCommitLength &gt;= log.size()) return;

  while(commitLength &lt; log.size()) {
    int acks = 0;
    for (auto &node : commo() -&gt; rpc_par_proxies_[0]) {
      siteid_t followerId = node.first;
      if (followerId != site_id_) {
        if(ackLength[followerId] &gt; commitLength) {
          acks++;
        }
      }
    }

    if(acks &gt;= (commo()-&gt;rpc_par_proxies_[0].size() / 2)) {
      app_next_(*(log[commitLength].cmd));
      commitLength++;
      Log_info("Node %d :: Leader Committing log entry %d for term %d :: Commit Length %d, Acks: %d", site_id_, commitLength + 1, log[commitLength].term, commitLength.load(), acks);
    } else {
      break;
    }
  }
}

/* Do not modify any code below here */

void RaftServer::Disconnect(const bool disconnect) {
  std::lock_guard&lt;std::recursive_mutex&gt; lock(mtx_);
  verify(disconnected_ != disconnect);
  // global map of rpc_par_proxies_ values accessed by partition then by site
  static map&lt;parid_t, map&lt;siteid_t, map&lt;siteid_t, vector&lt;SiteProxyPair&gt;&gt;&gt;&gt; _proxies{};
  if (_proxies.find(partition_id_) == _proxies.end()) {
    _proxies[partition_id_] = {};
  }
  RaftCommo *c = (RaftCommo*) commo();
  if (disconnect) {
    verify(_proxies[partition_id_][loc_id_].size() == 0);
    verify(c-&gt;rpc_par_proxies_.size() &gt; 0);
    auto sz = c-&gt;rpc_par_proxies_.size();
    _proxies[partition_id_][loc_id_].insert(c-&gt;rpc_par_proxies_.begin(), c-&gt;rpc_par_proxies_.end());
    c-&gt;rpc_par_proxies_ = {};
    verify(_proxies[partition_id_][loc_id_].size() == sz);
    verify(c-&gt;rpc_par_proxies_.size() == 0);
  } else {
    verify(_proxies[partition_id_][loc_id_].size() &gt; 0);
    auto sz = _proxies[partition_id_][loc_id_].size();
    c-&gt;rpc_par_proxies_ = {};
    c-&gt;rpc_par_proxies_.insert(_proxies[partition_id_][loc_id_].begin(), _proxies[partition_id_][loc_id_].end());
    _proxies[partition_id_][loc_id_] = {};
    verify(_proxies[partition_id_][loc_id_].size() == 0);
    verify(c-&gt;rpc_par_proxies_.size() == sz);
  }
  disconnected_ = disconnect;
}

bool RaftServer::IsDisconnected() {
  return disconnected_;
}

} // namespace janus</PRE>
</PRE>
</BODY>
</HTML>
