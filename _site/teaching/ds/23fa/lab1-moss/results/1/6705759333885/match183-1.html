<HTML>
<HEAD>
<TITLE>./github-lab1/dslabs-cpp-Surabhi-Gogte/src/deptran/raft/commo.cc</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
./github-lab1/dslabs-cpp-imtoobose/src/deptran/raft/commo.cc<p><PRE>

#include "commo.h"
#include "../rcc/graph.h"
#include "../rcc/graph_marshaler.h"
#include "../command.h"
#include "../procedure.h"
#include "../command_marshaler.h"
#include "raft_rpc.h"
#include "macros.h"

namespace janus
{

  RaftCommo::RaftCommo(PollMgr *poll) : Communicator(poll)
  {
  }

  shared_ptr&lt;IntEvent&gt; RaftCommo::BroadcastRequestVote(parid_t par_id,
                                                       siteid_t site_id,
                                                       uint64_t candidateId,
                                                       uint64_t candidateTerm,
                                                       uint64_t lastLogIndex,
                                                       uint64_t lastLogTerm,
                                                       shared_ptr&lt;uint64_t&gt; replyTerm,
                                                       shared_ptr&lt;uint64_t&gt; replyVotedFor)
  {
    auto proxies = rpc_par_proxies_[par_id];
    auto ev = Reactor::CreateSpEvent&lt;IntEvent&gt;(proxies.size());
    auto sz = proxies.size();
    *replyVotedFor = 0;
    *replyTerm = candidateTerm;
    for (auto &p : proxies)
    {
      if (p.first != candidateId)
      {
        RaftProxy *proxy = (RaftProxy *)p.second;
        FutureAttr fuattr;
        auto id = p.first;
        fuattr.callback = [id, candidateTerm, replyTerm, replyVotedFor, ev, sz](Future *fu)
        {
          uint64_t term;
          bool_t vote_granted;
          
          /* retrieve RPC return values in order */
          fu-&gt;get_reply() &gt;&gt; term;
          fu-&gt;get_reply() &gt;&gt; vote_granted;
          /* process the RPC response here */
          if (!vote_granted)
          {
            if (term &gt; candidateTerm)
            {
              if (*replyTerm &lt; term)
              {
                *replyTerm = term;
              }
            }
          }
          else
          {
            *replyVotedFor = *replyVotedFor + 1;
          }
          ev-&gt;Set(ev-&gt;get() + 1);
        };
        /* Always use Call_Async(proxy, RPC name, RPC args..., fuattr)
         * to asynchronously invoke RPCs */
        Call_Async(proxy, RequestVote, candidateId, candidateTerm, lastLogIndex, lastLogTerm, fuattr);
      }
    }
    return ev;
  }

  // single SendAppendEntries call, will set success if it reaches the server
  shared_ptr&lt;IntEvent&gt; RaftCommo::SendAppendEntries(
      parid_t par_id,
      siteid_t site_id,
      uint64_t leaderId,
<A NAME="1"></A><FONT color = #00FF00><A HREF="match183-0.html#1" TARGET="0"><IMG SRC="../../../bitmaps/tm_1_4.gif" ALT="other" BORDER="0" ALIGN=left></A>

      uint64_t leaderTerm,
      uint64_t prevLogIndex,
      uint64_t prevLogTerm,
      uint64_t leaderCommit,
      vector&lt;uint64_t&gt; terms,
      vector&lt;shared_ptr&lt;Marshallable&gt;&gt; cmds,
</FONT>
      shared_ptr&lt;uint64_t&gt; replyTerm,
      shared_ptr&lt;bool_t&gt; followerOK,
      shared_ptr&lt;bool_t&gt; success)
  {
    /*
     * More example code for sending a single RPC to server at site_id
     * You may modify and use this function or just use it as a reference
     */
    auto ev = Reactor::CreateSpEvent&lt;IntEvent&gt;(1);
    auto proxies = rpc_par_proxies_[par_id];
    *replyTerm = leaderTerm;
    *followerOK = false;
    *success = false;

    for (auto &p : proxies)
    {
      if (p.first == site_id)
      {
        RaftProxy *proxy = (RaftProxy *)p.second;
        FutureAttr fuattr;
        fuattr.callback = [replyTerm, followerOK, success, ev, site_id](Future *fu)
        {
          // Log_info("getting appendentries rpc callback");
<A NAME="0"></A><FONT color = #FF0000><A HREF="match183-0.html#0" TARGET="0"><IMG SRC="../../../bitmaps/tm_0_5.gif" ALT="other" BORDER="0" ALIGN=left></A>

          fu-&gt;get_reply() &gt;&gt; *replyTerm;
          fu-&gt;get_reply() &gt;&gt; *followerOK;
          fu-&gt;get_reply() &gt;&gt; *success;
          ev-&gt;Set(1);
          // Log_info("success getting appendentries rpc callback %d", site_id);
        };
        /* wrap Marshallable in a MarshallDeputy to send over RPC */
        vector&lt;MarshallDeputy&gt; marshalled;
        for (auto it : cmds)
        {
          MarshallDeputy md(it);
          marshalled.push_back(md);
</FONT>        }
        // Log_info("sending append entries rpc call from %d to %d", leaderId, site_id);
        Call_Async(proxy, AppendEntries, leaderId, leaderTerm, prevLogIndex, prevLogTerm, leaderCommit, terms, marshalled, fuattr);
      }
    }
    return ev;
  }

  shared_ptr&lt;IntEvent&gt; RaftCommo::BroadcastHeartBeat(parid_t par_id, uint64_t leaderId, uint64_t leaderTerm, uint64_t commitIndex, shared_ptr&lt;uint64_t&gt; replyTerm)
  {
    auto proxies = rpc_par_proxies_[par_id];
    auto sz = proxies.size();
    auto event = Reactor::CreateSpEvent&lt;IntEvent&gt;(sz);

    for (auto &p : proxies)
    {
      if (p.first != leaderId)
      {
        RaftProxy *proxy = (RaftProxy *)p.second;
        FutureAttr fuattr;
        auto id = p.first;
        fuattr.callback = [id, replyTerm, event](Future *fu)
        {
          uint64_t term;
          fu-&gt;get_reply() &gt;&gt; term;
          if (term &gt; *replyTerm)
          {
            *replyTerm = term;
          }
          event-&gt;Set(event-&gt;get() + 1);
        }; // end of callback
        Call_Async(proxy, EmptyAppendEntries, leaderTerm, leaderId, commitIndex, fuattr);
      }
    }
    return event;
  }

  shared_ptr&lt;IntEvent&gt;
  RaftCommo::SendString(parid_t par_id, siteid_t site_id, const string &msg, string *res)
  {
    auto proxies = rpc_par_proxies_[par_id];
    auto ev = Reactor::CreateSpEvent&lt;IntEvent&gt;();
    for (auto &p : proxies)
    {
      if (p.first == site_id)
      {
        RaftProxy *proxy = (RaftProxy *)p.second;
        FutureAttr fuattr;
        fuattr.callback = [res, ev](Future *fu)
        {
          fu-&gt;get_reply() &gt;&gt; *res;
          ev-&gt;Set(1);
        };
        /* wrap Marshallable in a MarshallDeputy to send over RPC */
        Call_Async(proxy, HelloRpc, msg, fuattr);
      }
    }
    return ev;
  }

} // namespace janus
</PRE>
</PRE>
</BODY>
</HTML>
