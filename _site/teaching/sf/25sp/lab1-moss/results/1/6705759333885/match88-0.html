<HTML>
<HEAD>
<TITLE>./github-lab1/dslabs-cpp-Pritish1/src/deptran/raft/service.cc</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
./github-lab1/dslabs-cpp-Pritish1/src/deptran/raft/service.cc<p><PRE>

#include "../marshallable.h"
#include "service.h"
#include "server.h"
namespace janus {

RaftServiceImpl::RaftServiceImpl(TxLogServer *sched)
    : svr_((RaftServer*)sched) {
	struct timespec curr_time;
	clock_gettime(CLOCK_MONOTONIC_RAW, &curr_time);
	srand(curr_time.tv_nsec);
}


void RaftServiceImpl::HandleRequestVote(const uint64_t& candidateTerm,
                                        const uint64_t& candidateId,
                                        const uint64_t& candidateLastLogIndex,
                                        const uint64_t& candidateLastLogTerm,
                                        int64_t *responseTerm,
                                        bool_t *voteGranted,
                                        rrr::DeferredReply* defer) {
  /* Your code here */
  svr_-&gt;mtx_.lock();
  bool isLogUptoDate = false;
  int currLastIndex = svr_-&gt;logs.size()-1;  
  int currLastTerm = svr_-&gt;logs[currLastIndex].term;
  int prevState = svr_-&gt;state;

  // Reply false if candidateTerm &lt; currentTerm
  if (candidateTerm &lt; svr_-&gt;currentTerm){
      Log_info("CANDIDATE TERM %d LOWER THAN CURR TERM %d =&gt; server %d candidate %d", candidateTerm, svr_-&gt;currentTerm, svr_-&gt;loc_id_, candidateId); 
      *voteGranted = false;
      *responseTerm = svr_-&gt;currentTerm;
<A NAME="1"></A><FONT color = #00FF00><A HREF="match88-1.html#1" TARGET="1"><IMG SRC="../../../bitmaps/tm_1_2.gif" ALT="other" BORDER="0" ALIGN=left></A>

      svr_-&gt;mtx_.unlock();
      defer-&gt;reply();
      return;
  }

  // Convert to follower state if candidateTerm &gt; currentTerm
  if (candidateTerm &gt; svr_-&gt;currentTerm){
    Log_info("CANDIDATE TERM %d HIGHER THAN CURR TERM %d =&gt; server %d state %d candidate %d", candidateTerm, svr_-&gt;currentTerm, svr_-&gt;loc_id_, svr_-&gt;state, candidateId);
</FONT>    svr_-&gt;currentTerm = candidateTerm;
    svr_-&gt;votedFor = -1;
    svr_-&gt;state = FOLLOWER;
    if(prevState != FOLLOWER){
      svr_-&gt;electionTimeout = (rand() % 300 + 400) * 1000;
      if(svr_-&gt;toEvent){
        Log_info("%d CONVERTED TO FOLLOWER TIMER RESET", svr_-&gt;loc_id_);
        svr_-&gt;toEvent-&gt;Set(1);
      }
    }
  }

  *voteGranted = false;
  *responseTerm = svr_-&gt;currentTerm;

  //ELECTION RESTRICTION
  if(candidateLastLogTerm == currLastTerm){
    isLogUptoDate = (candidateLastLogIndex &gt;= currLastIndex);
  } else {
    isLogUptoDate = (candidateLastLogTerm &gt; currLastTerm);
  }
  Log_info("ISLOGUPTODATE =&gt; %d Current Server %d Last Index %d Last Term %d || Candidate Server %d Last Index %d Last Term %d", isLogUptoDate, svr_-&gt;loc_id_, currLastIndex, currLastTerm, candidateId, candidateLastLogIndex, candidateLastLogTerm);

  
  if((svr_-&gt;votedFor == -1  || svr_-&gt;votedFor == candidateId) && isLogUptoDate){
    Log_info("VOTED =&gt; %d Granted vote to %d for term %d Resetting timer if prevState is follower : %d", svr_-&gt;loc_id_, candidateId, candidateTerm, prevState);
    *voteGranted = true;
    svr_-&gt;votedFor = candidateId; 
    if(svr_-&gt;toEvent && prevState == FOLLOWER){
        svr_-&gt;toEvent-&gt;Set(1);
    }
  }
  svr_-&gt;mtx_.unlock();
  defer-&gt;reply();
}

void RaftServiceImpl::HandleAppendEntries(const uint64_t& leaderTerm,
                                        const uint64_t& leaderId,
                                        const uint64_t& prevLogIndex,
                                        const uint64_t& prevLogTerm,
                                        const vector&lt;LogEntry&gt;& entries,
                                        const int64_t& leaderCommit,
                                        uint64_t* currTerm,
                                        bool_t* success,
                                        AEReply* aeReply,
                                        rrr::DeferredReply* defer) {
  /* Your code here */
  svr_-&gt;mtx_.lock();
  aeReply-&gt;conflictIndex = 0;
  aeReply-&gt;conflictTerm = 0;
  aeReply-&gt;serverId = svr_-&gt;loc_id_;
  aeReply-&gt;sizeOfEntries = entries.size();
  
  if (leaderTerm &lt; svr_-&gt;currentTerm){
      Log_info("LEADER %d OUTDATED =&gt; server %d", leaderId, svr_-&gt;loc_id_);
      *success = false;
      *currTerm = svr_-&gt;currentTerm;
      svr_-&gt;mtx_.unlock();
      defer-&gt;reply();
      return;
  }

  svr_-&gt;state = FOLLOWER;
  svr_-&gt;electionTimeout = (rand() % 300 + 400) * 1000;
  if(svr_-&gt;toEvent){
    svr_-&gt;toEvent-&gt;Set(1);
  }
  svr_-&gt;votedFor = -1;
  *success = true;
  *currTerm = leaderTerm;

  uint64_t myLastIndex = svr_-&gt;logs.size() - 1;
  // FOLLOWER HAS SMALLER LOG SIZE THAN WHAT LEADER THINKS
  if(prevLogIndex &gt; myLastIndex){
      *success = false;
      aeReply-&gt;conflictIndex = myLastIndex + 1;
      Log_info("FOLLOWER SHORTER THAN LEADER =&gt; server %d log size is %d leader %d conflictIndex %d", svr_-&gt;loc_id_, svr_-&gt;logs.size(), leaderId, aeReply-&gt;conflictIndex);
      svr_-&gt;mtx_.unlock();
      defer-&gt;reply();
      return;
  }

  uint64_t termAtPrevLogIndex = svr_-&gt;logs[prevLogIndex].term;
  // TERM AT PREVLOGINDEX DOES NOT MATCH, SEND THE FIRST INDEX OF CONFLICT TERM IN FOLLOWER'S LOG TO LEADER
  if (termAtPrevLogIndex != prevLogTerm){
    Log_info("LOG CONSISTENCY CHECK FAILED =&gt; conflictTerm %d | prevLogTerm %d", termAtPrevLogIndex, prevLogTerm);
    aeReply-&gt;conflictTerm = termAtPrevLogIndex;
    //returning the first index of the conflicting term in the follower
    for (int i = prevLogIndex; i &gt;= 0; i--){
        if(svr_-&gt;logs[i].term == termAtPrevLogIndex){
          aeReply-&gt;conflictIndex = i;
        } else
          break;
    }
    *success = false;
    svr_-&gt;mtx_.unlock();
    defer-&gt;reply();
    return;
  }
  //Compare the new logs with existing logs
  int followerLogIndex = prevLogIndex + 1;
  int entriesIndex = 0;

  //Find if there is a term mismatch between exsiting and new logs, if present, then we should truncate follower's logs after the mismatch
  while(followerLogIndex &lt; svr_-&gt;logs.size()+1 && entriesIndex &lt; entries.size()){
    if (svr_-&gt;logs[followerLogIndex].term != entries[entriesIndex].term){
      Log_info("TERM MISMATCH =&gt; Server %d Leader %d Follower log index %d term %d last index %d | Entries log index %d term %d", svr_-&gt;loc_id_, leaderId, followerLogIndex, svr_-&gt;logs[followerLogIndex].term, svr_-&gt;logs.size()-1, entriesIndex, entries[entriesIndex].term);
      break;
    }
    followerLogIndex++;
    entriesIndex++;
  }
  if(entriesIndex &lt; entries.size()){
    //This means there was mismatch in the logs, we can truncate the follower's logs
    if(followerLogIndex &lt; svr_-&gt;logs.size()){
      Log_info("TRUNCATING LOGS =&gt; of server %d leader %d entries size %d term mismatch at index %d in logs and %d in entries", svr_-&gt;loc_id_, leaderId, entries.size(), followerLogIndex, entriesIndex);
<A NAME="2"></A><FONT color = #0000FF><A HREF="match88-1.html#2" TARGET="1"><IMG SRC="../../../bitmaps/tm_2_2.gif" ALT="other" BORDER="0" ALIGN=left></A>

      std::vector&lt;LogEntry&gt; truncatedLogs(svr_-&gt;logs.begin(), svr_-&gt;logs.begin() + followerLogIndex);
      svr_-&gt;logs = truncatedLogs;
    }

    std::vector&lt;LogEntry&gt; slicedEntries(entries.begin() + entriesIndex, entries.end());
</FONT>    //append the remaining entries not present already in the follower's logs
    for(int i=0;i&lt;slicedEntries.size();i++){
      MarshallDeputy md = slicedEntries[i].md;
      uint16_t leaderTerm = slicedEntries[i].term;
      shared_ptr&lt;Marshallable&gt; sp = md.sp_data_;
      auto cmdptr_m = dynamic_pointer_cast&lt;TpcCommitCommand&gt;(sp);
      int command = cmdptr_m-&gt;tx_id_;
      std::cout&lt;&lt;"LOGS =&gt; Server "&lt;&lt;svr_-&gt;loc_id_&lt;&lt;" the command sent by leader"&lt;&lt;leaderId&lt;&lt;" recieved is : "&lt;&lt;command&lt;&lt;" and its term is "&lt;&lt;leaderTerm&lt;&lt;endl;
      svr_-&gt;logs.push_back(slicedEntries[i]);
    }
    aeReply-&gt;sizeOfEntries = slicedEntries.size();
  }
  
  if (leaderCommit &gt; svr_-&gt;commitIndex) {
		if (leaderCommit &lt; svr_-&gt;logs.size()-1) {
			svr_-&gt;commitIndex = leaderCommit;
		} else {
			svr_-&gt;commitIndex = svr_-&gt;logs.size()-1;
		}
    Log_info("%d COMMIT INDEX UPDATED to %d", svr_-&gt;loc_id_, svr_-&gt;commitIndex);
	}
  //apply logs till commit index
  for(int i=svr_-&gt;lastApplied+1;i&lt;=svr_-&gt;commitIndex;i++){
    shared_ptr&lt;Marshallable&gt; sp = svr_-&gt;logs[i].md.sp_data_;
    svr_-&gt;app_next_(*sp);
  }
<A NAME="0"></A><FONT color = #FF0000><A HREF="match88-1.html#0" TARGET="1"><IMG SRC="../../../bitmaps/tm_0_2.gif" ALT="other" BORDER="0" ALIGN=left></A>

  svr_-&gt;lastApplied = svr_-&gt;commitIndex;
  svr_-&gt;mtx_.unlock();
  defer-&gt;reply();
}

void RaftServiceImpl::HandleHelloRpc(const string& req,
                                     string* res,
                                     rrr::DeferredReply* defer) {
</FONT>  /* Your code here */
  svr_-&gt;state = FOLLOWER;
  defer-&gt;reply();
}

} // namespace janus;
</PRE>
</PRE>
</BODY>
</HTML>
