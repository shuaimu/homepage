<HTML>
<HEAD>
<TITLE>./github-lab1/dslabs-cpp-Sirneij/src/deptran/raft/commo.cc</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
./github-lab1/dslabs-cpp-Sirneij/src/deptran/raft/commo.cc<p><PRE>

#include "commo.h"
#include "../rcc/graph.h"
#include "../rcc/graph_marshaler.h"
#include "../command.h"
#include "../procedure.h"
#include "../command_marshaler.h"
#include "raft_rpc.h"
#include "macros.h"

namespace janus
{

<A NAME="0"></A><FONT color = #FF0000><A HREF="match115-1.html#0" TARGET="1"><IMG SRC="../../../bitmaps/tm_0_7.gif" ALT="other" BORDER="0" ALIGN=left></A>

  RaftCommo::RaftCommo(PollMgr *poll) : Communicator(poll)
  {
  }

  /**
   * @brief Handle vote RPC requests from server to another server.
   * 
   * @param par_id The partition ID of the server.
   * @param site_id The site ID of the server.
   * @param term The term of the requesting server.
   * @param candidate_id The ID of the requesting server.
   * @param last_log_index The index of the last log entry of the requesting server.
   * @param last_log_term The term of the last log entry of the requesting server.
   * @param reply_term The term of the replying server.
   * @param vote_granted Whether the replying server grants the vote.
   * 
   * @return shared_ptr&lt;IntEvent&gt;
   * 
   * @note This is a vote RPC request.
  */
  shared_ptr&lt;IntEvent&gt;
  RaftCommo::SendRequestVote(parid_t par_id, siteid_t site_id, const int64_t &term,
                             const int64_t &candidate_id,
                             const int64_t &last_log_index,
                             const int64_t &last_log_term, int64_t *reply_term,
</FONT>                             bool_t *vote_granted)
  {
    auto proxies = rpc_par_proxies_[par_id];
    auto ev = Reactor::CreateSpEvent&lt;IntEvent&gt;();
    for (auto &p : proxies)
    {
      if (p.first == site_id)
      {
        RaftProxy *proxy = (RaftProxy *)p.second;
        FutureAttr fuattr;
        fuattr.callback = [reply_term, vote_granted, ev](Future *fu)
        {
          fu-&gt;get_reply() &gt;&gt; *reply_term;
          fu-&gt;get_reply() &gt;&gt; *vote_granted;
          ev-&gt;Set(1);
        };
        /* wrap Marshallable in a MarshallDeputy to send over RPC */
        Call_Async(proxy, RequestVote, term, candidate_id, last_log_index, last_log_term, fuattr);
      }
    }
    return ev;
  }

  /**
   * @brief Handle empty append entries RPC requests from server to another server.
   * 
   * @param par_id The partition ID of the server.
   * @param site_id The site ID of the server.
   * @param term The term of the requesting server.
   * @param leader_id The ID of the requesting server.
   * @param prev_log_index The index of the previous log entry of the requesting server.
   * @param prev_log_term The term of the previous log entry of the requesting server.
   * @param log_term The term of the log entry of the requesting server.
   * @param log_cmd The command of the log entry of the requesting server.
   * @param leader_commit The commit index of the requesting server.
   * @param reply_term The term of the replying server.
   * @param followerAppendOK Whether the replying server grants the append entries.
   * 
   * @return shared_ptr&lt;IntEvent&gt;
   * 
   * @note This is an empty append entries RPC request.
  */
  shared_ptr&lt;IntEvent&gt; RaftCommo::SendEmptyAppendEntries(parid_t par_id,
                                                         siteid_t site_id,
                                                         const int64_t &term,
                                                         const locid_t &leader_id,
                                                         const int64_t &prev_log_index,
                                                         const int64_t &prev_log_term,
                                                         const int64_t &log_term,
                                                         const int64_t &log_cmd,
                                                         const int64_t &leader_commit,
                                                         int64_t *reply_term,
                                                         bool_t *followerAppendOK)
  {
    auto proxies = rpc_par_proxies_[par_id];
    auto ev = Reactor::CreateSpEvent&lt;IntEvent&gt;();
    for (auto &p : proxies)
    {
      if (p.first == site_id)
      {
        RaftProxy *proxy = (RaftProxy *)p.second;
        FutureAttr fuattr;
        fuattr.callback = [reply_term, followerAppendOK, ev](Future *fu)
        {
          fu-&gt;get_reply() &gt;&gt; *reply_term;
          fu-&gt;get_reply() &gt;&gt; *followerAppendOK;
          ev-&gt;Set(1);
        };
        /* wrap Marshallable in a MarshallDeputy to send over RPC */
        Call_Async(proxy, EmptyAppendEntries, term, leader_id, prev_log_index, prev_log_term, log_term, log_cmd, leader_commit, fuattr);
      }
    }
    return ev;
  }

  /**
   * @brief Handle append entries RPC requests from server to another server.
   * 
   * @param par_id The partition ID of the server.
   * @param site_id The site ID of the server.
   * @param term The term of the requesting server.
   * @param leader_id The ID of the requesting server.
   * @param prev_log_index The index of the previous log entry of the requesting server.
   * @param prev_log_term The term of the previous log entry of the requesting server.
   * @param leader_commit The commit index of the requesting server.
   * @param terms The terms of the log entries of the requesting server.
   * @param commands The commands of the log entries of the requesting server.
   * @param reply_term The term of the replying server.
   * @param followerAppendOK Whether the replying server grants the append entries.
   * @param conflict_index The index of the conflicting log entry of the replying server.
   * @param conflict_term The term of the conflicting log entry of the replying server.
   * 
   * @return shared_ptr&lt;IntEvent&gt;
   * 
   * @note This is an append entries RPC request.
  */
  shared_ptr&lt;IntEvent&gt; RaftCommo::SendAppendEntries(parid_t par_id,
                                                    siteid_t site_id,
                                                    const int64_t &term,
                                                    const locid_t &leader_id,
                                                    const int64_t &prev_log_index,
                                                    const int64_t &prev_log_term,
                                                    const int64_t &leader_commit,
                                                    const vector&lt;int64_t&gt; &terms,
                                                    const vector&lt;MarshallDeputy&gt; &commands,
                                                    int64_t *reply_term,
                                                    bool_t *followerAppendOK,
                                                    int64_t *conflict_index,
                                                    int64_t *conflict_term)
  {
    auto proxies = rpc_par_proxies_[par_id];
    auto ev = Reactor::CreateSpEvent&lt;IntEvent&gt;();
    for (auto &p : proxies)
    {
      if (p.first == site_id)
      {
        RaftProxy *proxy = (RaftProxy *)p.second;
        FutureAttr fuattr;
        fuattr.callback = [reply_term, followerAppendOK, conflict_index, conflict_term, ev](Future *fu)
        {
<A NAME="1"></A><FONT color = #00FF00><A HREF="match115-1.html#1" TARGET="1"><IMG SRC="../../../bitmaps/tm_1_4.gif" ALT="other" BORDER="0" ALIGN=left></A>

          fu-&gt;get_reply() &gt;&gt; *reply_term;
          fu-&gt;get_reply() &gt;&gt; *followerAppendOK;
          fu-&gt;get_reply() &gt;&gt; *conflict_index;
          fu-&gt;get_reply() &gt;&gt; *conflict_term;
          ev-&gt;Set(1);
</FONT>        };
        /* wrap Marshallable in a MarshallDeputy to send over RPC */
        // MarshallDeputy md(commands);
        Call_Async(proxy, AppendEntries, term, leader_id, prev_log_index, prev_log_term, leader_commit, terms, commands, fuattr);
      }
    }
    return ev;
  }

  shared_ptr&lt;IntEvent&gt;
  RaftCommo::SendString(parid_t par_id, siteid_t site_id, const string &msg, string *res)
  {
    auto proxies = rpc_par_proxies_[par_id];
    auto ev = Reactor::CreateSpEvent&lt;IntEvent&gt;();
    for (auto &p : proxies)
    {
      if (p.first == site_id)
      {
        RaftProxy *proxy = (RaftProxy *)p.second;
        FutureAttr fuattr;
        fuattr.callback = [res, ev](Future *fu)
        {
          fu-&gt;get_reply() &gt;&gt; *res;
          ev-&gt;Set(1);
        };
        /* wrap Marshallable in a MarshallDeputy to send over RPC */
        Call_Async(proxy, HelloRpc, msg, fuattr);
      }
    }
    return ev;
  }

} // namespace janus</PRE>
</PRE>
</BODY>
</HTML>
