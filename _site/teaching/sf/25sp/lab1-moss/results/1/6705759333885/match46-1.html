<HTML>
<HEAD>
<TITLE>./github-lab1/dslabs-cpp-Aditiii/src/deptran/raft/server.cc</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
./github-lab1/dslabs-cpp-aadarsh0301/src/deptran/raft/server.cc<p><PRE>
#include "server.h"
#include "exec.h"
#include "frame.h"
#include "coordinator.h"
#include "../classic/tpc_command.h"

namespace janus
{

  RaftServer::RaftServer(Frame *frame)
  {
    frame_ = frame;

    current_term = 0;
    votedFor = 50;
    serverTimer.start();
    currentRole = "FOLLOWER";
    isLeader = 0;
    commitIndex = 0;
  }

  RaftServer::~RaftServer()
  {
    currentRole = "FOLLOWER";
    isLeader = 0;
    votedFor = 50;
  }

  void RaftServer::Setup()
  {

    decideElectionTimeout();
  }

  bool RaftServer::Start(shared_ptr&lt;Marshallable&gt; &cmd,
                         uint64_t *index,
                         uint64_t *term)
  {

    if (isLeader)
    {
      mtx_.lock();
      logs.push_back({current_term, cmd});
      logStatus[site_id_].ack= logs.size();
      logStatus[site_id_].sent = logs.size();
<A NAME="0"></A><FONT color = #FF0000><A HREF="match46-0.html#0" TARGET="0"><IMG SRC="../../../bitmaps/tm_0_3.gif" ALT="other" BORDER="0" ALIGN=left></A>

      *index = logs.size();
      *term = current_term;
      mtx_.unlock();
      return true;
    }
    *index = 0;
    *term = 0;
    return false;
  }

  void RaftServer::GetState(bool *is_leader, uint64_t *term)
</FONT>  {
<A NAME="1"></A><FONT color = #00FF00><A HREF="match46-0.html#1" TARGET="0"><IMG SRC="../../../bitmaps/tm_1_2.gif" ALT="other" BORDER="0" ALIGN=left></A>

    *is_leader = isLeader;
    *term = current_term;
  }

  void RaftServer::SyncRpcExample()
  {
    Coroutine::CreateRun([this]()
                         {
    string res;
    auto event = commo()-&gt;SendString(0, 
</FONT>                                     0, "hello", &res);
    event-&gt;Wait(1000000); 
    if (event-&gt;status_ == Event::TIMEOUT) {
      Log_info("timeout happens");
    } else {
      Log_info("rpc response is: %s", res.c_str()); 
    } });
  }

  long long RaftServer::getElectionTimeout(int low, int high)
  {
    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&lt;long long&gt; distribution(low, high);
    long long random_timeout = distribution(generator);
    return random_timeout;
  }

  void RaftServer::decideElectionTimeout()
  {

    Coroutine::CreateRun([this]()
    { 
    while(true){
      long long elapsed = serverTimer.elapsed()*1000000;
      if(elapsed&gt;HEARTBEAT_INTERVAL && !IsDisconnected()){
     serverTimer.start();
        long long timeout=getElectionTimeout(400,800)*(site_id_+1)*1200;

       Coroutine::Sleep(timeout);
        elapsed = serverTimer.elapsed()*1000000;
      if(elapsed&gt;=timeout){
          currentRole="CANDIDATE";
        string vote_granted;
          uint64_t returnTerm;
         if(!isLeader && (currentRole=="CANDIDATE" && !IsDisconnected())){
           int totalVotes=1;
              int oldTerm=current_term;
              int newTerm=oldTerm+1;
              current_term=current_term+1;
              votedFor=site_id_;
<A NAME="2"></A><FONT color = #0000FF><A HREF="match46-0.html#2" TARGET="0"><IMG SRC="../../../bitmaps/tm_2_2.gif" ALT="other" BORDER="0" ALIGN=left></A>

            for(int i=0 ;i&lt;5;i++){
                    if(site_id_!=i){ 
                  auto event =commo()-&gt;SendAskForVote(0,site_id_,i,newTerm,logs.size()&gt;0?logs.size():0,
</FONT>                                                logs.size()&gt;0?logs[logs.size()-1].term:0, &vote_granted ,&returnTerm);
                    event-&gt;Wait(50000); 
                    if(vote_granted=="YES"){
                   totalVotes++;
                    }
                    else if(vote_granted=="NO"){
                      currentRole="FOLLOWER";
                      current_term=returnTerm;
                      votedFor=50;
                    }
                    if(totalVotes&gt;2 && currentRole=="CANDIDATE"){
                    isLeader=1;
                    //  Log_info("*********************Site %d becoming leader*************************",site_id_);
                      currentRole="LEADER";
                      for (int j = 0; j &lt; 5; j++)
                      {
                          logStatus[j].ack=0;
                          logStatus[j].sent=logs.size();
                      }                  
                      SendHeartbeats();
                    }           
                  }
              }      
            }
        } 
         
      }
      Coroutine::Sleep(40000);   
    } });
  }

  void RaftServer::SendHeartbeats()
  {
    Coroutine::CreateRun([this]()
    {
    while(isLeader) {
      uint64_t returnTerm;
      string success;
      uint64_t ackLen = 0;
      uint64_t returnLogSize = 0;
      for (int serverId=0; serverId&lt;5; serverId++) {
          if(site_id_ != serverId) {
            uint64_t prefixLen = logStatus[serverId].sent;
            vector&lt;MarshallDeputy&gt; leaderLogs;
            vector&lt;uint64_t&gt; leaderTerms;
            for(int i=0;i&lt;logs.size();i++){
              MarshallDeputy md(logs[i].cmd);
              leaderLogs.push_back(md);
              leaderTerms.push_back(logs[i].term);
            }
            auto event = commo()-&gt;SendEntries(0, current_term, site_id_,prefixLen,commitIndex, 
              serverId,leaderLogs,leaderTerms,&returnTerm, &success, &ackLen, &returnLogSize);
              event-&gt;Wait(20000);
              
            if(returnTerm == current_term && isLeader){
            if(success=="YES" && ackLen&gt;=logStatus[serverId].ack){
                  logStatus[serverId].ack=ackLen;
                 
                  while(commitIndex&lt;logs.size()){
                    int acks=0;
                    for(int i=0;i&lt;5;i++){
                      if(logStatus[i].ack&gt;commitIndex){
                        acks++;
                        if(acks&gt;2)
                          break;
                      }
                    }
                  if(acks&gt;2){
                    app_next_(*logs[commitIndex].cmd);
                        commitIndex++;
                    }else{
                      break;
                    }
                  }
              
                } else if(logStatus[serverId].sent&gt;0){
                  logStatus[serverId].sent=logStatus[serverId].sent-1;
                } 
              }else if(returnTerm&gt; current_term){
                current_term=returnTerm;
                currentRole="FOLLOWER";
                votedFor=50;
                isLeader=0;
                serverTimer.start();
              }
          }
        }
      }// Coroutine::Sleep(200000); 
      });
  }

  /* Do not modify any code below here */

  void RaftServer::Disconnect(const bool disconnect)
  {
    std::lock_guard&lt;std::recursive_mutex&gt; lock(mtx_);
    verify(disconnected_ != disconnect);
    // global map of rpc_par_proxies_ values accessed by partition then by site
    static map&lt;parid_t, map&lt;siteid_t, map&lt;siteid_t, vector&lt;SiteProxyPair&gt;&gt;&gt;&gt; _proxies{};
    if (_proxies.find(partition_id_) == _proxies.end())
    {
      _proxies[partition_id_] = {};
    }
    RaftCommo *c = (RaftCommo *)commo();
    if (disconnect)
    {
      verify(_proxies[partition_id_][loc_id_].size() == 0);
      verify(c-&gt;rpc_par_proxies_.size() &gt; 0);
      auto sz = c-&gt;rpc_par_proxies_.size();
      _proxies[partition_id_][loc_id_].insert(c-&gt;rpc_par_proxies_.begin(), c-&gt;rpc_par_proxies_.end());
      c-&gt;rpc_par_proxies_ = {};
      verify(_proxies[partition_id_][loc_id_].size() == sz);
      verify(c-&gt;rpc_par_proxies_.size() == 0);
    }
    else
    {
      verify(_proxies[partition_id_][loc_id_].size() &gt; 0);
      auto sz = _proxies[partition_id_][loc_id_].size();
      c-&gt;rpc_par_proxies_ = {};
      c-&gt;rpc_par_proxies_.insert(_proxies[partition_id_][loc_id_].begin(), _proxies[partition_id_][loc_id_].end());
      _proxies[partition_id_][loc_id_] = {};
      verify(_proxies[partition_id_][loc_id_].size() == 0);
      verify(c-&gt;rpc_par_proxies_.size() == sz);
    }
    disconnected_ = disconnect;
  }

  bool RaftServer::IsDisconnected()
  {
    return disconnected_;
  }

} // namespace janus
</PRE>
</PRE>
</BODY>
</HTML>
