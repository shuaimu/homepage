<HTML>
<HEAD>
<TITLE>/root/ds-labs-ta/github-lab3/shuai-teaching/dslabs-cpp-akashpatil-219/src/shardmaster/service.cc</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
/root/ds-labs-ta/github-lab3/shuai-teaching/dslabs-cpp-aadarsh0301/src/shardmaster/service.cc<p><PRE>
#include &lt;boost/archive/text_oarchive.hpp&gt;
#include &lt;boost/archive/text_iarchive.hpp&gt;
#include "service.h"
#include "client.h"
#include "../kv/server.h"

namespace janus {

<A NAME="5"></A><FONT color = #FF0000><A HREF="match0-0.html#5" TARGET="0"><IMG SRC="../../../bitmaps/tm_0_4.gif" ALT="other" BORDER="0" ALIGN=left></A>

void ShardMasterServiceImpl::Join(const map&lt;uint32_t, std::vector&lt;uint32_t&gt;&gt;& gid_server_map, uint32_t* ret, rrr::DeferredReply* defer) {
  // your code here
 
  uint32_t newGroupId = gid_server_map.begin()-&gt;first;
</FONT>  ShardConfig prevConfig;
  if(configs_.size() == 0){
    for(int i=1;i&lt;=10;i++){
      prevConfig.shard_group_map_[i] = 1;
    }
    prevConfig.group_servers_map_ = gid_server_map;
  }
  else{
    prevConfig = configs_[configs_.size()];

    if(prevConfig.group_servers_map_.find(newGroupId) != prevConfig.group_servers_map_.end()){
      *ret = KV_SUCCESS;
      defer-&gt;reply();
      return;
    }

    for(auto gid: gid_server_map){
      prevConfig.group_servers_map_[gid.first] = gid.second;
    }

    map&lt;uint32_t, vector&lt;uint32_t&gt; &gt; groupToShards;
    for(auto i: prevConfig.shard_group_map_){
      groupToShards[i.second].push_back(i.first);
    }
   
<A NAME="2"></A><FONT color = #0000FF><A HREF="match0-0.html#2" TARGET="0"><IMG SRC="../../../bitmaps/tm_2_10.gif" ALT="other" BORDER="0" ALIGN=left></A>

    uint32_t n = prevConfig.group_servers_map_.size();
    uint32_t quotient = (uint32_t)(10)/(n);
    uint32_t remainder = (uint32_t)(10)%(n);
   
    for(auto i: groupToShards){
      int currCount = i.second.size();
      int required = quotient;
      if(remainder){
        required++;
        remainder--;
      }
      int difference = currCount-required;
      for(int j=0;j&lt;difference;j++){
        uint32_t shard = i.second[i.second.size()-1];
</FONT>        prevConfig.shard_group_map_[shard] = newGroupId;
        i.second.pop_back();
      }
    }
  }

    ShardConfig shardConfig;
    shardConfig.number = configs_.size()+1;
    shardConfig.shard_group_map_ = prevConfig.shard_group_map_;
    shardConfig.group_servers_map_ = prevConfig.group_servers_map_;
<A NAME="4"></A><FONT color = #FF00FF><A HREF="match0-0.html#4" TARGET="0"><IMG SRC="../../../bitmaps/tm_4_4.gif" ALT="other" BORDER="0" ALIGN=left></A>

    configs_[shardConfig.number] = shardConfig;

    *ret = KV_SUCCESS;
     defer-&gt;reply();
}

void ShardMasterServiceImpl::Leave(const std::vector&lt;uint32_t&gt;& gids, uint32_t* ret, rrr::DeferredReply* defer) {
</FONT>  
  ShardConfig prevConfig= configs_[configs_.size()];
  map&lt;uint32_t, vector&lt;uint32_t&gt; &gt; groupToShards;
<A NAME="3"></A><FONT color = #00FFFF><A HREF="match0-0.html#3" TARGET="0"><IMG SRC="../../../bitmaps/tm_3_7.gif" ALT="other" BORDER="0" ALIGN=left></A>

  for(auto i: prevConfig.shard_group_map_){
    groupToShards[i.second].push_back(i.first);
  }

  vector&lt;uint32_t&gt;allocateShards;
  for(auto groupID: gids){
    allocateShards.insert(allocateShards.end(),groupToShards[groupID].begin(),groupToShards[groupID].end());
    groupToShards.erase(groupID);
</FONT><A NAME="1"></A><FONT color = #00FF00><A HREF="match0-0.html#1" TARGET="0"><IMG SRC="../../../bitmaps/tm_1_11.gif" ALT="other" BORDER="0" ALIGN=left></A>

    prevConfig.group_servers_map_.erase(groupID);
  }

  int groupCount = groupToShards.size();
  uint32_t quotient = (uint32_t)(10)/(groupCount);
  uint32_t remainder = (uint32_t)(10)%(groupCount);

  for(auto gts: groupToShards){
    int grp = gts.first;
    int currCount = gts.second.size();
    int required = quotient;
    if(remainder){
      required++;
      remainder--;
    }
    int difference = required - currCount;
    for(int j=0; j &lt; difference; j++){
      int shard = allocateShards.back();
</FONT>      prevConfig.shard_group_map_[shard] = grp;
      allocateShards.pop_back();
    }
  }

  ShardConfig shardConfig;
  shardConfig.number = configs_.size()+1;
  shardConfig.group_servers_map_ = prevConfig.group_servers_map_;
  shardConfig.shard_group_map_ = prevConfig.shard_group_map_;
<A NAME="6"></A><FONT color = #00FF00><A HREF="match0-0.html#6" TARGET="0"><IMG SRC="../../../bitmaps/tm_1_4.gif" ALT="other" BORDER="0" ALIGN=left></A>

  configs_[shardConfig.number] = shardConfig;

  *ret = KV_SUCCESS;
  defer-&gt;reply();
}
void ShardMasterServiceImpl::Move(const int32_t& shard, const uint32_t& gid, uint32_t* ret, rrr::DeferredReply* defer) {
</FONT>  // your code here
<A NAME="0"></A><FONT color = #FF0000><A HREF="match0-0.html#0" TARGET="0"><IMG SRC="../../../bitmaps/tm_0_13.gif" ALT="other" BORDER="0" ALIGN=left></A>

  defer-&gt;reply();
}
void ShardMasterServiceImpl::Query(const int32_t& config_no, uint32_t* ret, ShardConfig* config, rrr::DeferredReply* defer) {
  // your code here
  int lastestConfigNumber = configs_.size();
  if(config_no == -1 || lastestConfigNumber &lt; config_no){
    *config = configs_[lastestConfigNumber];
  }
  else{
    *config = configs_[config_no];
  }
  *ret = KV_SUCCESS;
  defer-&gt;reply();
}

void ShardMasterServiceImpl::OnNextCommand(Marshallable& m) {
  // your code here
}

// do not change anything below
shared_ptr&lt;ShardMasterClient&gt; ShardMasterServiceImpl::CreateClient() {
  auto cli = make_shared&lt;ShardMasterClient&gt;();
  cli-&gt;commo_ = sp_log_svr_-&gt;commo_;
</FONT>  uint32_t id = sp_log_svr_-&gt;site_id_;
  return cli;
}

} // namespace janus</PRE>
</PRE>
</BODY>
</HTML>
