<HTML>
<HEAD>
<TITLE>./github-lab2/dslabs-cpp-4molybdenum2/src/kv/server.cc</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
./github-lab2/dslabs-cpp-4molybdenum2/src/kv/server.cc<p><PRE>
#include "../deptran/__dep__.h"
#include "server.h"
#include "../deptran/raft/server.h"
#include "client.h"

namespace janus {

static int volatile x1 =
    MarshallDeputy::RegInitializer(MarshallDeputy::CMD_MULTI_STRING,
                                     [] () -&gt; Marshallable* {
                                       return new MultiStringMarshallable;
                                     });

int64_t KvServer::GetNextOpId() {
  verify(sp_log_svr_);
  int64_t ret = sp_log_svr_-&gt;site_id_;
  ret = ret &lt;&lt; 32;
  ret = ret + op_id_cnt_++; 
  return ret;
}

/* submit to lab2 (3rd try) */
int KvServer::Put(const uint64_t& oid, 
                  const string& k,
                  const string& v) {
  /* 
  Your are recommended to use MultiStringMarshallable as the format 
  for the log entries. Here is an example how you can use it.
  auto s = make_shared&lt;MultiStringMarshallable&gt;();
  s-&gt;data_.push_back(to_string(op_id));
  s-&gt;data_.push_back("put");
  s-&gt;data_.push_back(k);
  s-&gt;data_.push_back(v);
  */
  /* your code here */

  /* need to check whether this server is leader or not
  all client operations go through leader
  */

 /*
  For put commands, on starting an agreement value is applied to the log
  But it is not committed so we can't directly return success to the user
  After it is committed we return KV_SUCCESS
  else we timeout, client can retry

  retrying an append operation shouldn't put duplicate values
 
 */
  std::lock_guard&lt;std::recursive_mutex&gt; lock(mtx);

  auto &svr = GetRaftServer();
  uint64_t index, term;

  auto s = make_shared&lt;MultiStringMarshallable&gt;();
  s-&gt;data_.push_back(to_string(oid));
  s-&gt;data_.push_back("put");
  s-&gt;data_.push_back(k);
  s-&gt;data_.push_back(v);

  auto cmd = dynamic_pointer_cast&lt;Marshallable&gt;(s);
  bool ok = svr.Start(cmd, &index, &term);

  if(!ok) {
    return KV_NOTLEADER; // retry on different server
  }

  Coroutine::Sleep(OP_TIMEOUT); // sleep for 700 milliseconds and check

  if(completedOps.find(to_string(oid)) == completedOps.end()) {
    return KV_TIMEOUT;
  }

  return KV_SUCCESS;
}

int KvServer::Append(const uint64_t& oid, 
                     const string& k,
                     const string& v) {
  /* your code here */
  std::lock_guard&lt;std::recursive_mutex&gt; lock(mtx);

  auto &svr = GetRaftServer();
  uint64_t index, term;

  auto s = make_shared&lt;MultiStringMarshallable&gt;();
  s-&gt;data_.push_back(to_string(oid));
  s-&gt;data_.push_back("append");
  s-&gt;data_.push_back(k);
  s-&gt;data_.push_back(v);

  auto cmd = dynamic_pointer_cast&lt;Marshallable&gt;(s);
  bool ok = svr.Start(cmd, &index, &term);

  if(!ok) {
    return KV_NOTLEADER; // retry on different server
  }

  Coroutine::Sleep(OP_TIMEOUT); // sleep for 700 milliseconds and check

  if(completedOps.find(to_string(oid)) == completedOps.end()) {
    return KV_TIMEOUT;
  }

  return KV_SUCCESS;
}

int KvServer::Get(const uint64_t& oid, 
                  const string& k,
                  string* v) {
  /* your code here */
  std::lock_guard&lt;std::recursive_mutex&gt; lock(mtx);

  auto &svr = GetRaftServer();
  uint64_t index, term;

  auto s = make_shared&lt;MultiStringMarshallable&gt;();
  s-&gt;data_.push_back(to_string(oid));
  s-&gt;data_.push_back("get");
  s-&gt;data_.push_back(k);

  auto cmd = dynamic_pointer_cast&lt;Marshallable&gt;(s);
  bool ok = svr.Start(cmd, &index, &term);

  if(!ok) {
    return KV_NOTLEADER; // retry on different server
  }

  Coroutine::Sleep(OP_TIMEOUT); // sleep for 700 milliseconds and check
  if(completedOps.find(to_string(oid)) == completedOps.end()) {
<A NAME="0"></A><FONT color = #FF0000><A HREF="match21-1.html#0" TARGET="1"><IMG SRC="../../../bitmaps/tm_0_13.gif" ALT="other" BORDER="0" ALIGN=left></A>

    return KV_TIMEOUT;
  }
  *v = kvstore[k];
  return KV_SUCCESS;
}

void KvServer::OnNextCommand(Marshallable& m) {
  auto s = (MultiStringMarshallable*)(&m);
  /* your code here */

  /* get committed operations into a queue*/
  auto data = s-&gt;data_;
  if(data[1] == "put") {
    kvstore[data[2]] = data[3];
  } else if(data[1] == "append") {
    kvstore[data[2]] += data[3];
</FONT>  }

<A NAME="1"></A><FONT color = #00FF00><A HREF="match21-1.html#1" TARGET="1"><IMG SRC="../../../bitmaps/tm_1_5.gif" ALT="other" BORDER="0" ALIGN=left></A>

  completedOps.insert(data[0]);
}

shared_ptr&lt;KvClient&gt; KvServer::CreateClient() {
  /* don't change this function */
  auto cli = make_shared&lt;KvClient&gt;();
  verify(commo_ != nullptr);
  cli-&gt;commo_ = commo_;
</FONT>  uint32_t id = sp_log_svr_-&gt;site_id_;
  id = id &lt;&lt; 16;
  cli-&gt;cli_id_ = id+cli_cnt_++; 
  return cli;
}

} // namespace janus;</PRE>
</PRE>
</BODY>
</HTML>
