<HTML>
<HEAD>
<TITLE>./github-lab1/dslabs-cpp-Linyqsbu/src/deptran/raft/server.cc</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
./github-lab1/dslabs-cpp-msiddhu/src/deptran/raft/server.cc<p><PRE>


#include "server.h"

#include &lt;utility&gt;
// #include "paxos_worker.h"
#include "exec.h"
#include "frame.h"
#include "coordinator.h"


namespace janus {


    RaftServer::RaftServer(Frame *frame) {
        frame_ = frame;
        /* Your code here for server initialization. Note that this function is
           called in a different OS thread. Be careful about thread safety if
           you want to initialize variables here. */
    }

    RaftServer::~RaftServer() {
        /* Your code here for server teardown */

    }

    void RaftServer::Setup() {
        /* Your code here for server setup. Due to the asynchronous nature of the
           framework, this function could be called after a RPC handler is triggered.
           Your code should be aware of that. This function is always called in the
           same OS thread as the RPC handlers. */
        nextIndex.resize(5, 1);
        matchIndex.resize(5, 0);
        commitIndex = 0;
        myServerId = loc_id_;
        currentTerm = 0;
        votedFor = -1;
        currentState = FOLLOWER;
        lastApplied = 0;
        recvVotes = 0;
        lastWakeTime.start();
        electionProcessor();
        heartbeatProcessor();

        //TODO: these should be synced with threads.
        //TODO: what are these params

    }


<A NAME="3"></A><FONT color = #00FFFF><A HREF="match19-0.html#3" TARGET="0"><IMG SRC="../../../bitmaps/tm_3_1.gif" ALT="other" BORDER="0" ALIGN=left></A>

    bool RaftServer::Start(shared_ptr&lt;Marshallable&gt; &cmd, uint64_t *index, uint64_t *term) {

        //TODO: check if we have to use index and term
        //TODO: should call reset timer and start() function somewhere
        //reset the last heart beat to now
        std::lock_guard&lt;std::recursive_mutex&gt; lock(mtx_);
        if (currentState != LEADER) {
</FONT>            return false;
        }
        LogEntry logEntry(cmd, currentTerm);
        //Log_info("current term %d",currentTerm);
        logEntries.push_back(logEntry);
        matchIndex[myServerId] = logEntries.size();

        *term = currentTerm;
        *index = matchIndex[myServerId];
        return true;
    }

    void RaftServer::GetState(bool *is_leader, uint64_t *term) {
        /* Your code here. This function can be called from another OS thread. */
        *term = currentTerm;
        *is_leader = (currentState == LEADER);
    }

//    void RaftServer::SyncRpcExample() {
//        /* This is an example of synchronous RPC using coroutine; feel free to
//           modify this function to dispatch/receive your own messages.
//           You can refer to the other function examples in commo.h/cc on how
//           to send/recv a Marshallable object over RPC. */
//        Coroutine::CreateRun([this]() {
//            string res;
//            auto event = commo()-&gt;SendString(0, /* partition id is always 0 for lab1 */
//                                             0, "hello", &res);
//            event-&gt;Wait(100 * 1000); //timeout after 1000000us=1s
//            if (event-&gt;status_ == Event::TIMEOUT) {
//                Log_info("timeout happens");
//            } else {
//                Log_info("rpc response is: %s", res.c_str());
//            }
//        });
//
//    }


    void RaftServer::listenForAppendEntries(
            const uint64_t &term,
            const uint64_t &leaderId,
            const uint64_t &prevLogIndex,
            const uint64_t &prevLogTerm,
            const uint64_t &leaderCommit,
<A NAME="2"></A><FONT color = #0000FF><A HREF="match19-0.html#2" TARGET="0"><IMG SRC="../../../bitmaps/tm_2_1.gif" ALT="other" BORDER="0" ALIGN=left></A>

            vector&lt;shared_ptr&lt;Marshallable&gt;&gt; &cmds,
            uint64_t *followerTerm,
            bool_t *followerAppendOK,
            int64_t *conflictTerm,
            int64_t *conflictIndex
    ) {

        std::lock_guard&lt;std::recursive_mutex&gt; lock(mtx_);
</FONT>

        if (currentTerm &gt; term) return;

        if (currentTerm &lt;= term) {
            currentState = FOLLOWER;
            currentTerm = term;
            //  if(!recvLogs.empty()) Log_info("retrun here2");
            if (currentTerm &lt; term) votedFor = -1;
        }

        *conflictIndex = -1;
        *conflictTerm = -1;
        *followerTerm = currentTerm;
        *followerAppendOK = false;
        vector&lt;LogEntry&gt; recvLogs;
        for (shared_ptr&lt;Marshallable&gt; &cmd: cmds) {
            recvLogs.push_back(LogEntry(cmd, term));
        }
        //Log_info("%d")
        lastWakeTime.start();
        uint64_t logSize;
        if (logEntries.empty()) {
            *followerAppendOK = true;
            logEntries.insert(logEntries.end(), recvLogs.begin(), recvLogs.end());
            if (leaderCommit &gt; commitIndex) {
                commitIndex = min(leaderCommit, logEntries.size());
                CommitLogs();
            }
            return;
        }

        if (prevLogIndex &gt; logEntries.size()) {
            *followerAppendOK = false;
            *conflictIndex = logEntries.size();
            // Log_info("retrun here3");
            return;
        }
        logSize = logEntries.size();
        if (0 &lt; prevLogIndex && !logEntries.empty() && (logEntries[prevLogIndex - 1].term != prevLogTerm)) {
            *followerAppendOK = false;
            //            if(logEntries.size()&lt;prevLogIndex){
            //                Log_info("dangeerrrr^^^^^^^");
            //            }
            *conflictTerm = logEntries[prevLogIndex - 1].term;
            uint64_t i = 1;
            while (i &lt;= prevLogIndex) {
                //check function
//                if(index-1&lt;0 || index &gt; logEntries.size()){
//                    Log_info("@@@@ ");
//                }
                if (*conflictTerm == logEntries[i - 1].term) {
                    *conflictIndex = i;
                    break;
                }
                i++;
            }
            //Log_info("retrun here4");
            return;
        }

        //removing and again applying logs
        //resize function not able to use
        uint64_t i = prevLogIndex;
        while (i &lt; logSize) {
            logEntries.pop_back();
            i++;
        }
        logEntries.insert(logEntries.end(), recvLogs.begin(), recvLogs.end());

        logSize = logEntries.size();
        if (leaderCommit &gt; commitIndex) {
            commitIndex = min(logSize, leaderCommit);
            CommitLogs();
        }
        *followerAppendOK = true;
    }

//    void RaftServer::BroadcastAppendEntries(const vector&lt;shared_ptr&lt;Marshallable&gt;&gt;& cmds){
//        Log_info("broadcasting entries");
//            for(auto otherServerId :otherServerInfo) {
//                if (otherServerId == myServerId) continue;
//                    AppendEntries(otherServerId, cmds);
//            }
//    }

    void RaftServer::CommitLogs() {
        std::lock_guard&lt;std::recursive_mutex&gt; lock(mtx_);
        for (uint64_t i = lastApplied; i &lt; commitIndex; i++) {
            app_next_(*logEntries[i].cmd);
            // Log_info("### pushed to app next serverid: %d",loc_id_);
        }
        lastApplied = commitIndex;
    }


    void RaftServer::AppendEntries(uint64_t otherServerId) {

        uint64_t prevLogIndex;
        uint64_t prevLogTerm;
        uint64_t leaderId;
        uint64_t followerTerm;
        bool_t followerAppendOK;
        int64_t conflictTerm;
        int64_t conflictIndex;
        vector&lt;shared_ptr&lt;Marshallable&gt;&gt; cmds;
        {
            std::lock_guard&lt;std::recursive_mutex&gt; lock(mtx_);
            leaderId = myServerId;

            followerTerm = 0;
            followerAppendOK = false;
            conflictTerm = -1;
            conflictIndex = -1;
            prevLogIndex = this-&gt;nextIndex[otherServerId] - 1;
            //edge case
            if (prevLogIndex == 0) {
                prevLogTerm = 0;
                if (!logEntries.empty()) {
                    prevLogTerm = logEntries[0].term;
                }
            } else {
//
                if (logEntries.size() &lt; prevLogIndex) {
                    Log_info("danger$$$$");
                }
                prevLogTerm = logEntries[prevLogIndex - 1].term;
            }

            for (uint64_t idx = prevLogIndex; idx &lt; logEntries.size(); idx++) {
                cmds.push_back(logEntries[idx].cmd);
            }
        }
        commo()-&gt;SendAppendEntries(0,
<A NAME="1"></A><FONT color = #00FF00><A HREF="match19-0.html#1" TARGET="0"><IMG SRC="../../../bitmaps/tm_1_1.gif" ALT="other" BORDER="0" ALIGN=left></A>

                                   otherServerId,
                                   currentTerm,
                                   leaderId,
                                   prevLogIndex,
                                   prevLogTerm,
                                   commitIndex,
                                   cmds,
                                   &followerTerm,
                                   &followerAppendOK,
                                   &conflictTerm,
                                   &conflictIndex
        );
        Coroutine::Sleep(1000);
</FONT>        {
            std::lock_guard&lt;std::recursive_mutex&gt; lock1(mtx_);
            if (followerTerm &gt; currentTerm) {
                // Log_info("Server id: %d I became a follower of %d term number: %d myterm %d", loc_id_, otherServerId,
                //        followerTerm, currentTerm);
                currentState = FOLLOWER;
                currentTerm = followerTerm;
                votedFor = -1;
                return;
            }

            if (followerAppendOK) {
                nextIndex[otherServerId] += cmds.size();
                matchIndex[otherServerId] = nextIndex[otherServerId] - 1;
                vector&lt;uint64_t&gt; matchIndexCopy = matchIndex;
                sort(matchIndexCopy.begin(), matchIndexCopy.end());
                uint64_t majorityMatchIndex = matchIndexCopy[matchIndexCopy.size() / 2];
//                if(logEntries.size()&lt;majorityMatchIndex){
//                    Log_info("Danger))))");
//                }
                if (majorityMatchIndex &gt; commitIndex && !logEntries.empty() &&
                    logEntries[majorityMatchIndex - 1].term == currentTerm) {
                    commitIndex = majorityMatchIndex;
                    //  Log_info("majority greater than now");
                    CommitLogs();
                }
            }
            if (!followerAppendOK) {
                if (conflictTerm == -1) {
                    nextIndex[otherServerId] = max((int64_t) 1, conflictIndex + 1);
                } else {
                    int64_t lConflictIdx = -1;
                    uint64_t idx = prevLogIndex;
                    while (idx &gt;= 1) {
                        if (!logEntries.empty() && conflictTerm == logEntries[idx - 1].term) {
                            lConflictIdx = idx;
                            break;
                        }
                        idx--;
                    }
                    if (lConflictIdx == -1) {
                        nextIndex[otherServerId] = max((int64_t) 1, conflictIndex);
                    } else {
                        nextIndex[otherServerId] = lConflictIdx + 1;
                    }
                }
            }
        }
    }

    void RaftServer::sendAllRequestVotes() {
        for (auto otherServerId: this-&gt;otherServerInfo) {
            uint64_t lastLogTerm;
            uint64_t lastLogIndex;
            uint64_t peer_term = 0;
            bool_t peer_vote = false;
            {
                std::lock_guard&lt;std::recursive_mutex&gt; lock(mtx_);
                if (otherServerId == loc_id_) {
                    continue;
                }
                lastLogTerm = logEntries.size() != 0 ? logEntries.back().term : 0;
                lastLogIndex = logEntries.size();
            }
            //  Log_info("Requesting vote from %d to %d",loc_id_,otherServerId);
            //DONE: implement last log term afterwords
            auto event = commo()-&gt;SendRequestVote(0, otherServerId, currentTerm, myServerId, lastLogIndex,
                                                  lastLogTerm, &peer_term, &peer_vote);

            //Wait for 2 second
            Coroutine::Sleep(1000);
//                event-&gt;Wait();
            {
                std::lock_guard&lt;std::recursive_mutex&gt; lock1(mtx_);
                if (peer_term &gt; currentTerm) {
                    currentTerm = peer_term;
                    votedFor = -1;
                    currentState = FOLLOWER;
                }
                if (peer_vote) recvVotes++;
                if (CANDIDATE != currentState) continue;

                if ((otherServerInfo.size() / 2) &lt; recvVotes) {
                    //         Log_info("made the leader %d with termID %d",loc_id_, currentTerm);
                    for (int i = 0; i &lt; otherServerInfo.size(); i++) {
                        matchIndex[i] = 0;
                        nextIndex[i] = 1 + logEntries.size();
                    }
                    lastHeartBeatTime.start();
                    currentState = LEADER;
                    break;
                }
            }
        }
    }

    void RaftServer::listenForRequestVote(
            const uint64_t &candidateId,
<A NAME="0"></A><FONT color = #FF0000><A HREF="match19-0.html#0" TARGET="0"><IMG SRC="../../../bitmaps/tm_0_1.gif" ALT="other" BORDER="0" ALIGN=left></A>

            const uint64_t &candidateTerm,
            const uint64_t &lastLogTerm,
            const uint64_t &lastLogIndex,
            uint64_t *term,
            bool_t *vote
    ) {
        std::lock_guard&lt;std::recursive_mutex&gt; lock(mtx_);
</FONT>        *vote = false;
        *term = currentTerm;

        if (currentTerm &gt; candidateTerm)
            return;


        if (currentTerm &lt; candidateTerm) {
            votedFor = -1;
            currentTerm = candidateTerm;
            currentState = FOLLOWER;
        }

        if ((votedFor == candidateId || votedFor == -1) && ifLogUptoDate(lastLogIndex, lastLogTerm)) {
            lastWakeTime.start();
            *vote = true;
            votedFor = candidateId;
        }
    }

    void RaftServer::heartbeatProcessor() {
        Coroutine::CreateRun([this]() {
            while (true) {
                Coroutine::Sleep(1000);
//                if(IsDisconnected()){
//                    continue;
//                }
                if (this-&gt;currentState !=  LEADER)
                    continue;

                uint64_t during_time = (lastHeartBeatTime.elapsed() * 1000000);
                if (during_time &lt; HEARTBEAT_INTERVAL) {
                    continue;
                }
                lastHeartBeatTime.start();

                for (auto otherServerId: this-&gt;otherServerInfo) {
                    if (otherServerId == this-&gt;myServerId)
                        continue;
                    AppendEntries(otherServerId);
                }
            }
        });
    }

    void RaftServer::electionProcessor() {
        Coroutine::CreateRun([this]() {
            // Log_info("Running couroutine electionProcessor");
//            while(!IsDisconnected()){
            int timeOut = generateRandomNumber();
            while (true) {
                Coroutine::Sleep(1000);
//
//                Log_info("time out time %d",timeOut);
//                Log_info("ServerId %d",loc_id_);
                int during_time = (lastWakeTime.elapsed() * 1000000);
                if (during_time &gt; timeOut && this-&gt;currentState == FOLLOWER) {
                    this-&gt;currentState = CANDIDATE;
                }
                if (during_time &gt; timeOut && this-&gt;currentState == CANDIDATE) {
                    lastWakeTime.start();
                    this-&gt;currentTerm++;
                    this-&gt;votedFor = this-&gt;myServerId;
                    this-&gt;recvVotes = 1;
                    //   Log_info("leader election for %d, currentTerm is %d",loc_id_,currentTerm);
                    sendAllRequestVotes();
                }
            }
//            }
        });
    }

    bool RaftServer::ifLogUptoDate(uint64_t index, uint64_t term) {
        if (0 == logEntries.size() || logEntries.back().term &lt; term ||
            (index &gt;= logEntries.size() && term == logEntries.back().term)) {
            return true;
        }
        return false;
    }

    LogEntry::LogEntry(shared_ptr&lt;Marshallable&gt; &cmd, uint64_t term) {
        this-&gt;cmd = cmd;
        this-&gt;term = term;
    }

    //used chatGPT to get this code.
    int RaftServer::generateRandomNumber() {
        std::lock_guard&lt;std::recursive_mutex&gt; lock(mtx_);
        std::random_device rd;  // Seed the random number generator with a hardware entropy source
        std::mt19937 gen(rd()); // Create a Mersenne Twister PRNG
        std::uniform_int_distribution&lt;int&gt; distribution(3000000, 4000000); // Define the range
        return distribution(gen); // Generate and return a random number in the specified range
    }

/* Do not modify any code below here */

    void RaftServer::Disconnect(const bool disconnect) {
        std::lock_guard&lt;std::recursive_mutex&gt; lock(mtx_);
        verify(disconnected_ != disconnect);
        // global map of rpc_par_proxies_ values accessed by partition then by site
        static map&lt;parid_t, map&lt;siteid_t, map&lt;siteid_t, vector&lt;SiteProxyPair&gt;&gt;&gt;&gt; _proxies{};
        if (_proxies.find(partition_id_) == _proxies.end()) {
            _proxies[partition_id_] = {};
        }
        RaftCommo *c = (RaftCommo *) commo();
        if (disconnect) {
            verify(_proxies[partition_id_][loc_id_].size() == 0);
            verify(c-&gt;rpc_par_proxies_.size() &gt; 0);
            auto sz = c-&gt;rpc_par_proxies_.size();
            _proxies[partition_id_][loc_id_].insert(c-&gt;rpc_par_proxies_.begin(), c-&gt;rpc_par_proxies_.end());
            c-&gt;rpc_par_proxies_ = {};
            verify(_proxies[partition_id_][loc_id_].size() == sz);
            verify(c-&gt;rpc_par_proxies_.size() == 0);
        } else {
            verify(_proxies[partition_id_][loc_id_].size() &gt; 0);
            auto sz = _proxies[partition_id_][loc_id_].size();
            c-&gt;rpc_par_proxies_ = {};
            c-&gt;rpc_par_proxies_.insert(_proxies[partition_id_][loc_id_].begin(),
                                       _proxies[partition_id_][loc_id_].end());
            _proxies[partition_id_][loc_id_] = {};
            verify(_proxies[partition_id_][loc_id_].size() == 0);
            verify(c-&gt;rpc_par_proxies_.size() == sz);
        }
        disconnected_ = disconnect;
    }

    bool RaftServer::IsDisconnected() {
        return disconnected_;
    }
} // namespace janus
</PRE>
</PRE>
</BODY>
</HTML>
