<HTML>
<HEAD>
<TITLE>./github-lab2/dslabs-cpp-bhaveshgawri/src/kv/server.cc</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
./github-lab2/dslabs-cpp-bhaveshgawri/src/kv/server.cc<p><PRE>
#include "../deptran/__dep__.h"
#include "server.h"
#include "../deptran/raft/server.h"
#include "client.h"

namespace janus {

static int volatile x1 =
    MarshallDeputy::RegInitializer(MarshallDeputy::CMD_MULTI_STRING,
                                     [] () -&gt; Marshallable* {
                                       return new MultiStringMarshallable;
                                     });

<A NAME="2"></A><FONT color = #0000FF><A HREF="match7-1.html#2" TARGET="1"><IMG SRC="../../../bitmaps/tm_2_3.gif" ALT="other" BORDER="0" ALIGN=left></A>

int64_t KvServer::GetNextOpId() {
  verify(sp_log_svr_);
  int64_t ret = sp_log_svr_-&gt;site_id_;
  ret = ret &lt;&lt; 32;
  ret = ret + op_id_cnt_++; 
  return ret;
}

shared_ptr&lt;Marshallable&gt; KvServer::GenOperation(const string& op_type,
</FONT><A NAME="1"></A><FONT color = #00FF00><A HREF="match7-1.html#1" TARGET="1"><IMG SRC="../../../bitmaps/tm_1_4.gif" ALT="other" BORDER="0" ALIGN=left></A>

                                                const uint64_t& op_id,
                                                const string& key,
                                                const string& val) {
  auto op = make_shared&lt;MultiStringMarshallable&gt;();
  op -&gt; data_.push_back(op_type);
</FONT>  op -&gt; data_.push_back(to_string(op_id));
  op -&gt; data_.push_back(key);
  op -&gt; data_.push_back(val);
  cout &lt;&lt; "[RAFT_KV] Op generated op_type: " &lt;&lt; op_type &lt;&lt; " | op_id: " &lt;&lt; op_id &lt;&lt; " | key: " &lt;&lt; key &lt;&lt; " | val: " &lt;&lt; val &lt;&lt; endl;
  return op;
}

uint64_t KvServer::ExecOperation(const string& op_type,
                                 const uint64_t& op_id,
                                 const string& key,
                                 const string& val) {
  uint64_t ret = KV_TIMEOUT;
  auto& raft = GetRaftServer();
  cout &lt;&lt; "[RAFT_KV] Executing op, raft type: " &lt;&lt; raft.type &lt;&lt; " | site_id: " &lt;&lt; raft.site_id_ &lt;&lt; endl;

  if (raft.type == 2) {
    auto op = GenOperation(op_type, op_id, key, val);

    uint64_t raft_term, raft_index;
    raft.Start(op, &raft_index, &raft_term);

    // operations map for concurrent reqs
    operations[op_id] = Reactor::CreateSpEvent&lt;IntEvent&gt;();    
    operations[op_id] -&gt; Wait(1000 * 1000); // 1s

    ret = operations[op_id] -&gt; status_ == Event::DONE ? KV_SUCCESS : KV_TIMEOUT;
    operations.erase(op_id);
  } else {
    ret = KV_NOTLEADER;
  } 
  return ret;
}

<A NAME="0"></A><FONT color = #FF0000><A HREF="match7-1.html#0" TARGET="1"><IMG SRC="../../../bitmaps/tm_0_4.gif" ALT="other" BORDER="0" ALIGN=left></A>

int KvServer::Put(const uint64_t& oid, 
                  const string& k,
                  const string& v) {
  cout &lt;&lt; "[RAFT_KV] Issuing PUT for key: " &lt;&lt; k &lt;&lt; " | value: " &lt;&lt; v &lt;&lt; endl; 
</FONT>  auto ret = ExecOperation(PUT, oid, k, v);
  cout &lt;&lt; "[RAFT_KV] Success PUT for key: " &lt;&lt; k &lt;&lt; " | value: " &lt;&lt; v &lt;&lt; " | ret: " &lt;&lt; ret &lt;&lt; endl; 
  
  // // if (ret == KV_SUCCESS) {
  //   kvs[k] = v;
  // // }
  return ret;
}

int KvServer::Append(const uint64_t& oid, 
                     const string& k,
                     const string& v) {
  cout &lt;&lt; "[RAFT_KV] Issuing APPEND for key: " &lt;&lt; k &lt;&lt; " | value: " &lt;&lt; v &lt;&lt; endl;
  auto ret = ExecOperation(APPEND, oid, k, v);
<A NAME="3"></A><FONT color = #00FFFF><A HREF="match7-1.html#3" TARGET="1"><IMG SRC="../../../bitmaps/tm_3_3.gif" ALT="other" BORDER="0" ALIGN=left></A>

  cout &lt;&lt; "[RAFT_KV] Success APPEND for key: " &lt;&lt; k &lt;&lt; " | value: " &lt;&lt; v &lt;&lt; " | ret: " &lt;&lt; ret &lt;&lt; endl;

  // // if (ret == KV_SUCCESS) {
  //   if (kvs.count(k)) kvs[k] += v;
  //   else kvs[k] = v;
  // // }
  return ret;
}

int KvServer::Get(const uint64_t& oid, 
                  const string& k,
                  string* v) {
  cout &lt;&lt; "[RAFT_KV] Issuing GET for key: " &lt;&lt; k &lt;&lt; endl;
</FONT>  auto ret = ExecOperation(GET, oid, k, DEFAULT_GET_VALUE);
  cout &lt;&lt; "[RAFT_KV] Success GET for key: " &lt;&lt; k &lt;&lt; " | value: " &lt;&lt; v &lt;&lt; " | ret: " &lt;&lt; ret &lt;&lt; endl;

  *v = ret == KV_SUCCESS && kvs.count(k) ? kvs[k] : DEFAULT_GET_VALUE;
  return ret;
}

uint64_t KvServer::UpdateKVStore(MultiStringMarshallable* op) {
  string op_type = op -&gt; data_[0], op_id = op -&gt; data_[1], key = op -&gt; data_[2], val = op -&gt; data_[3];
  cout &lt;&lt; "[RAFT_KV] Agreement for op_type: " &lt;&lt; op_type &lt;&lt; " | op_id: " &lt;&lt; op_id &lt;&lt; " | key: " &lt;&lt; key &lt;&lt; " | val: " &lt;&lt; val &lt;&lt; endl;
  if (op_type == APPEND && kvs.count(key)) 
    kvs[key] += val;
  else if (op_type == PUT || op_type == APPEND)
    kvs[key] = val; 
  cout &lt;&lt; "[RAFT_KV] kvs["&lt;&lt;key&lt;&lt;"]: " &lt;&lt; kvs[key] &lt;&lt; endl; 
  return stoull(op_id);
}

void KvServer::OnNextCommand(Marshallable& m) {
  auto& raft = GetRaftServer();
  cout &lt;&lt; "[RAFT_KV] app_next_() callback from site: " &lt;&lt; raft.site_id_ &lt;&lt; " | raft.type: " &lt;&lt; raft.type &lt;&lt; " | curr_leader: " &lt;&lt; raft.leaderId &lt;&lt; endl;
  if (raft.type == 2) {
    // fixes test #5: update kvs, then mark success
    // 1. Move kv updates from put/append function to onnextcommand: on leader change, 
    //       need to update kvs for all log values that are not committed on new leader, 
    //       when updating from put/append funcs only one log value was getting updated [test5 - fail1.log]
    // 2. Only call Set(1), when op_id in operations  [test5 - fail2.log]
    uint64_t op_id = UpdateKVStore((MultiStringMarshallable*)(&m));
    if (operations.count(op_id))
      operations[op_id] -&gt; Set(1);
  }
}

shared_ptr&lt;KvClient&gt; KvServer::CreateClient() {
  /* don't change this function */
  auto cli = make_shared&lt;KvClient&gt;();
  verify(commo_ != nullptr);
  cli-&gt;commo_ = commo_;
  uint32_t id = sp_log_svr_-&gt;site_id_;
  id = id &lt;&lt; 16;
  cli-&gt;cli_id_ = id+cli_cnt_++; 
  return cli;
}

} // namespace janus;</PRE>
</PRE>
</BODY>
</HTML>
