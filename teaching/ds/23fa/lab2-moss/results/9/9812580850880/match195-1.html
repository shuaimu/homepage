<HTML>
<HEAD>
<TITLE>./github-lab2/dslabs-cpp-ahuja-gautam/src/kv/server.cc</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
./github-lab2/dslabs-cpp-shivani232/src/kv/server.cc<p><PRE>
#include "../deptran/__dep__.h"
#include "server.h"
#include "../deptran/raft/server.h"
#include "client.h"

namespace janus {

static int volatile x1 =
    MarshallDeputy::RegInitializer(MarshallDeputy::CMD_MULTI_STRING,
                                     [] () -&gt; Marshallable* {
                                       return new MultiStringMarshallable;
                                     });

int64_t KvServer::GetNextOpId() {
  verify(sp_log_svr_);
  int64_t ret = sp_log_svr_-&gt;site_id_;
  ret = ret &lt;&lt; 32;
  ret = ret + op_id_cnt_++; 
  return ret;
}

<A NAME="0"></A><FONT color = #FF0000><A HREF="match195-0.html#0" TARGET="0"><IMG SRC="../../../bitmaps/tm_0_3.gif" ALT="other" BORDER="0" ALIGN=left></A>

int KvServer::Put(const uint64_t& oid, 
                  const string& k,
                  const string& v) {

  
  /* 
  Your are recommended to use MultiStringMarshallable as the format 
  for the log entries. Here is an example how you can use it.
  auto s = make_shared&lt;MultiStringMarshallable&gt;();
  s-&gt;data_.push_back(to_string(op_id));
  s-&gt;data_.push_back("put");
  s-&gt;data_.push_back(k);
  s-&gt;data_.push_back(v);
  */
  /* your code here */

  RaftServer& peer = GetRaftServer();

  Log_info(" ******* Put req: oid: %d k: %s v: %s peer: %d",oid, k.c_str(),v.c_str(), peer.loc_id_);
</FONT>
  // Return not leader if the associated raft peer is not the leader
  if (peer.state != PEER_STATE_LEADER){
    return KV_NOTLEADER;
  }

  /*
  1. Call start
  2. sleep for 0.5 secs until agreement happens and we handle it inside onNext
  3. Check in our DB if we have added the kv pair. If yes return success if no then failed to add


  */


  auto s = make_shared&lt;MultiStringMarshallable&gt;();
  s-&gt;data_.push_back(to_string(oid));
  s-&gt;data_.push_back("put");
  s-&gt;data_.push_back(k);
  s-&gt;data_.push_back(v);

  auto cmd = dynamic_pointer_cast&lt;Marshallable&gt;(s);
  uint64_t index, term;

  //Call start
  peer.Start(cmd, &index,&term);

  Log_info("Inside put before Sleep");
  // sleep for 0.5 secs until agreement happens and we handle it inside onNext
  event_put.Set(0);
  int event_timeout = 1;
  event_put.WaitUntilGreaterOrEqualThan(500000, 500000);

  Log_info("Inside put after  Sleep");
  
  if(event_put.value_ == 1){
   // Log_info("At 1");
    if(db.find(k) != db.end() && db[k] == v){
      Log_info("At 2");
      Log_info("Put Oid: %d LocID: %d Return success",oid,peer.loc_id_);
     return KV_SUCCESS;
    }
  }

Log_info("Put Oid: %d LocID: %d Return timeout",oid,peer.loc_id_);
  
return KV_TIMEOUT;
  
}

int KvServer::Append(const uint64_t& oid, 
                     const string& k,
                     const string& v) {
  RaftServer& peer = GetRaftServer();

  // Return not leader if the associated raft peer is not the leader
  if (peer.state != PEER_STATE_LEADER){
    return KV_NOTLEADER;
  }

  Log_info(" ******* Append req: oid: %d  k: %s v: %s peer: %d",oid, k.c_str(),v.c_str(), peer.loc_id_);

  auto s = make_shared&lt;MultiStringMarshallable&gt;();
  s-&gt;data_.push_back(to_string(oid));
  s-&gt;data_.push_back("append");
  s-&gt;data_.push_back(k);
  s-&gt;data_.push_back(v);

  auto cmd = dynamic_pointer_cast&lt;Marshallable&gt;(s);
  uint64_t index, term;

  //Call start
  peer.Start(cmd, &index,&term);

  Log_info("Inside append before Sleep");
  
  event_append.Set(0);
  int event_timeout = 1;
  event_append.WaitUntilGreaterOrEqualThan(500000, 500000);

  Log_info("Inside append after Sleep");

  
  // if(db.find(k) != db.end()){

  //   string val = db[k];
  //   int start = val.size() - v.size();

  //   if (val.substr(start,v.size()) == v){

  //     return KV_SUCCESS;
      
  //   }
     
  // }else{
  //   return KV_TIMEOUT;
  // }

  if(event_append.value_ == 1){
    Log_info("Append Oid: %d LocID: %d Return success",oid,peer.loc_id_);
    return KV_SUCCESS;
  }

  Log_info("Append Oid: %d LocID: %d Return timeout",oid, peer.loc_id_);

  return KV_TIMEOUT;



}

int KvServer::Get(const uint64_t& oid, 
                  const string& k,
                  string* v) {

  Log_info(" ******* Get req: oid: %d  k: %s ",oid, k.c_str());
  /* your code here */
<A NAME="1"></A><FONT color = #00FF00><A HREF="match195-0.html#1" TARGET="0"><IMG SRC="../../../bitmaps/tm_1_3.gif" ALT="other" BORDER="0" ALIGN=left></A>

   RaftServer& peer = GetRaftServer();

  //if (peer.state != )


  auto s = make_shared&lt;MultiStringMarshallable&gt;();
  s-&gt;data_.push_back(to_string(oid));
  s-&gt;data_.push_back("get");
  s-&gt;data_.push_back(k);
</FONT>  
  auto cmd = dynamic_pointer_cast&lt;Marshallable&gt;(s);
  uint64_t index, term;

  //Call start
  bool is_leader = peer.Start(cmd, &index,&term);

  Log_info("Inside Get before Sleep");
  //if(is_leader){

    // sleep for 0.5 secs until agreement happens and we handle it inside onNext
    event_get.Set(0);
    int event_timeout = 1;
    event_get.WaitUntilGreaterOrEqualThan(event_timeout, 500000);

 // }
  

  Log_info("Inside Get after Sleep");

  if(( !(GetRaftServer().IsDisconnected())) &&(db.find(k) != db.end())){
     
     *v = db[k];
     Log_info(" Get value: %s", v-&gt;c_str());
     
     return KV_SUCCESS;
  }

  Log_info("Get timed out");
  
  return KV_TIMEOUT;
  
}

void KvServer::OnNextCommand(Marshallable& m) {
  //auto v = (MultiStringMarshallable*)(&m);
  /* your code here */
  auto cmd = dynamic_cast&lt;MultiStringMarshallable*&gt;(&m);
  RaftServer& peer = GetRaftServer();

  if (cmd-&gt;data_.empty()){
    Log_info(" Error Empty Command");
    return;

  }

  

  const string& cmd_type = cmd-&gt;data_[1];
  
  
  if(cmd_type == "put"){
   
    // add key value in db if operation success
    db[cmd-&gt;data_[2]] = cmd-&gt;data_[3];
    event_put.Set(1);
    Log_info("*** Put to map : OID: %s K: %s v: %s ",cmd-&gt;data_[0].c_str(),cmd-&gt;data_[2].c_str(),cmd-&gt;data_[3].c_str());

  }

  else if(cmd_type == "append"){

    string k,arg;
    k = cmd-&gt;data_[2];
    arg = cmd-&gt;data_[3];
    // if key not in db, add key  
    if(db.find(k) == db.end()){

    db[k] = arg;
      // event set 

    }else{
      // if key in db, append arg to its value
      db[k] += arg;
      // event set
    }

    Log_info("*** Append to map : OID: %s K: %s v: %s ",cmd-&gt;data_[0].c_str(),k.c_str(),db[k].c_str());

    event_append.Set(1);

  }
  else if(cmd_type == "get"){
    event_get.Set(1);
    Log_info("*** Get from  map : OID: %s K: %s",cmd-&gt;data_[0],cmd-&gt;data_[2].c_str());

  }
  
 
}

// shared_ptr&lt;IntEvent&gt; KvServer::CreateEvent(parid_t par_id, siteid_t site_id, const string& msg, string* res) {
//   auto proxies = rpc_par_proxies_[par_id];
//   auto ev = Reactor::CreateSpEvent&lt;IntEvent&gt;();
//   for (auto& p : proxies) {
//     if (p.first == site_id) {
//       RaftProxy *proxy = (RaftProxy*) p.second;
//       FutureAttr fuattr;
//       fuattr.callback = [res,ev](Future* fu) {
//         fu-&gt;get_reply() &gt;&gt; *res;
//         ev-&gt;Set(1);
//       };
//       /* wrap Marshallable in a MarshallDeputy to send over RPC */
//       Call_Async(proxy, HelloRpc, msg, fuattr);
//     }
//   }
//   return ev;
// }
shared_ptr&lt;KvClient&gt; KvServer::CreateClient() {
  /* don't change this function */
  auto cli = make_shared&lt;KvClient&gt;();
  verify(commo_ != nullptr);
  cli-&gt;commo_ = commo_;
  uint32_t id = sp_log_svr_-&gt;site_id_;
  id = id &lt;&lt; 16;
  cli-&gt;cli_id_ = id+cli_cnt_++; 
  return cli;
}

} // namespace janus;</PRE>
</PRE>
</BODY>
</HTML>
