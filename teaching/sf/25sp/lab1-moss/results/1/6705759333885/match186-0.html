<HTML>
<HEAD>
<TITLE>./github-lab1/dslabs-cpp-PranavDani/src/deptran/raft/commo.cc</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
./github-lab1/dslabs-cpp-PranavDani/src/deptran/raft/commo.cc<p><PRE>

#include "commo.h"
#include "../rcc/graph.h"
#include "../rcc/graph_marshaler.h"
#include "../command.h"
#include "../procedure.h"
#include "../command_marshaler.h"
#include "raft_rpc.h"
#include "macros.h"

namespace janus {

  RaftCommo::RaftCommo(PollMgr* poll) : Communicator(poll) {
  }

  // void RaftCommo::SendRequestVote(parid_t par_id,
  //   siteid_t site_id,
  //   uint64_t arg1,
  //   uint64_t arg2) {
  //   /*
  //    * Example code for sending a single RPC to server at site_id
  //    * You may modify and use this function or just use it as a reference
  //    */
  //   auto proxies = rpc_par_proxies_[par_id];
  //   for (auto& p : proxies) {
  //     if (p.first == site_id) {
  //       RaftProxy* proxy = (RaftProxy*)p.second;
  //       FutureAttr fuattr;
  //       fuattr.callback = [](Future* fu) {
  //         /* this is a handler that will be invoked when the RPC returns */
  //         uint64_t ret1;
  //         bool_t vote_granted;
  //         /* retrieve RPC return values in order */
  //         fu-&gt;get_reply() &gt;&gt; ret1;
  //         fu-&gt;get_reply() &gt;&gt; vote_granted;
  //         /* process the RPC response here */
  //         };
  //       /* Always use Call_Async(proxy, RPC name, RPC args..., fuattr)
  //       * to asynchronously invoke RPCs */
  //       Call_Async(proxy, RequestVote, arg1, arg2, fuattr);
  //     }
  //   }
  // }
  // Original Version

  // Sends RequestVote RPCs during leader election.
  shared_ptr&lt;IntEvent&gt; RaftCommo::SendRequestVote(parid_t par_id, siteid_t site_id, uint64_t term, uint64_t candidateId, uint64_t lastLogIndex, uint64_t lastLogTerm, int64_t* replyTerm, int64_t* voteGranted) {

    auto proxies = rpc_par_proxies_[par_id];
    auto ev = Reactor::CreateSpEvent&lt;IntEvent&gt;();
    for (auto& p : proxies) {
      if (p.first == site_id) {
        RaftProxy* proxy = (RaftProxy*)p.second;
        FutureAttr fuattr;
        fuattr.callback = [voteGranted, replyTerm, site_id, candidateId, ev](Future* fu) {
          /* this is a handler that will be invoked when the RPC returns */
          // bool_t vote_granted;

          /* retrieve RPC return values in order */
          fu-&gt;get_reply() &gt;&gt; *replyTerm;
          fu-&gt;get_reply() &gt;&gt; *voteGranted;

          if (*voteGranted == 1) {
            Log_info("%d Received vote inside commo from %d", candidateId, site_id);
            *voteGranted = 1;
          }

          Log_info("%d Received replyTerm %d which is different", site_id, *replyTerm);

          /* process the RPC response here */

          ev-&gt;Set(1);
          };
        /* Always use Call_Async(proxy, RPC name, RPC args..., fuattr)
        * to asynchronously invoke RPCs */
        Call_Async(proxy, RequestVote, term, candidateId, lastLogIndex, lastLogTerm, fuattr);
      }
    }
<A NAME="0"></A><FONT color = #FF0000><A HREF="match186-1.html#0" TARGET="1"><IMG SRC="../../../bitmaps/tm_0_4.gif" ALT="other" BORDER="0" ALIGN=left></A>

    return ev;
  }


  // Depricated. It was used for sending heartbeats initially.
  shared_ptr&lt;IntEvent&gt; RaftCommo::SendEmptyAppendEntries(parid_t par_id, siteid_t site_id, uint64_t term, uint64_t candidateId, int64_t* replyTerm, int64_t* voteGranted) {
    auto proxies = rpc_par_proxies_[par_id];
</FONT>    auto ev = Reactor::CreateSpEvent&lt;IntEvent&gt;();
    for (auto& p : proxies) {
      if (p.first == site_id) {
        RaftProxy* proxy = (RaftProxy*)p.second;
        FutureAttr fuattr;
        fuattr.callback = [voteGranted, replyTerm, site_id, candidateId, ev](Future* fu) {
          /* this is a handler that will be invoked when the RPC returns */
          // bool_t vote_granted;

          /* retrieve RPC return values in order */
          fu-&gt;get_reply() &gt;&gt; *replyTerm;
          fu-&gt;get_reply() &gt;&gt; *voteGranted;

          if (*voteGranted == 1) {
            Log_info("%d Received emptycommovote from %d", candidateId, site_id);
            *voteGranted = 1;
          }

          Log_info("%d Received replyTerm %d, vote granted %d in emptycommonope", site_id, *replyTerm, *voteGranted);

          /* process the RPC response here */

<A NAME="1"></A><FONT color = #00FF00><A HREF="match186-1.html#1" TARGET="1"><IMG SRC="../../../bitmaps/tm_1_4.gif" ALT="other" BORDER="0" ALIGN=left></A>

          ev-&gt;Set(1);
          };
        /* Always use Call_Async(proxy, RPC name, RPC args..., fuattr)
        * to asynchronously invoke RPCs */
        Call_Async(proxy, EmptyAppendEntries, term, candidateId, fuattr);
      }
    }
    return ev;
  }



  // This is used to push append entries and commands to other servers. 
  shared_ptr&lt;IntEvent&gt; RaftCommo::SendAppendEntries(parid_t par_id, siteid_t site_id, uint64_t term, uint64_t candidateId, uint64_t prevLogIndex, uint64_t prevLogTerm, vector&lt;shared_ptr&lt;Marshallable&gt;&gt; logEntrycommand, vector&lt;uint32_t&gt; logEntryTerm, uint64_t leaderCommit, int64_t* replyTerm, int64_t* success) {
</FONT>    auto proxies = rpc_par_proxies_[par_id];
    auto ev = Reactor::CreateSpEvent&lt;IntEvent&gt;();



    for (auto& p : proxies) {
      if (p.first == site_id) {
        RaftProxy* proxy = (RaftProxy*)p.second;
        FutureAttr fuattr;
        fuattr.callback = [success, replyTerm, site_id, candidateId, ev](Future* fu) {
          /* this is a handler that will be invoked when the RPC returns */
          // bool_t vote_granted;

          /* retrieve RPC return values in order */
          fu-&gt;get_reply() &gt;&gt; *replyTerm;
          fu-&gt;get_reply() &gt;&gt; *success;

          if (*success == 1) {
            Log_info("%d Received AppendEntries response from %d", candidateId, site_id);
            *success = 1;
          }

          /* process the RPC response here */

          ev-&gt;Set(1);
          };
        /* Always use Call_Async(proxy, RPC name, RPC args..., fuattr)
        * to asynchronously invoke RPCs */


        vector&lt;MarshallDeputy&gt; cmd;
        for (int i = 0; i &lt; logEntrycommand.size(); i++) {
          MarshallDeputy md(logEntrycommand[i]);
          cmd.push_back(md);
        }

        // Log_info("Request received");


        // MarshallDeputy md(logEntrycommand);
        Call_Async(proxy, AppendEntries, term, candidateId, prevLogIndex, prevLogTerm, cmd, logEntryTerm, leaderCommit, fuattr);

      }
    }
    return ev;
  }


  // Experimentation for testing the usage of the function.
  void RaftCommo::SendExampleRpc(parid_t par_id, siteid_t site_id, const string& msg, string* res) {
    auto proxies = rpc_par_proxies_[par_id];
    auto ev = Reactor::CreateSpEvent&lt;IntEvent&gt;();
    for (auto& p : proxies) {
      if (p.first == site_id) {
        RaftProxy* proxy = (RaftProxy*)p.second;
        FutureAttr fuattr;
        fuattr.callback = [res, ev, site_id](Future* fu) {
          fu-&gt;get_reply() &gt;&gt; *res;
          Log_info("Response mil gaya %d", site_id);
          ev-&gt;Set(1);
          };
        /* wrap Marshallable in a MarshallDeputy to send over RPC */
        Call_Async(proxy, ExampleRpc, msg, fuattr);
        Log_info("Called Async");
      }
    }
  }



  // void RaftCommo::SendAppendEntries(parid_t par_id,
  //   siteid_t site_id,
  //   shared_ptr&lt;Marshallable&gt; cmd) {
  //   /*
  //    * More example code for sending a single RPC to server at site_id
  //    * You may modify and use this function or just use it as a reference
  //    */
  //   auto proxies = rpc_par_proxies_[par_id];
  //   for (auto& p : proxies) {
  //     if (p.first == site_id) {
  //       RaftProxy* proxy = (RaftProxy*)p.second;
  //       FutureAttr fuattr;
  //       fuattr.callback = [](Future* fu) {
  //         bool_t followerAppendOK;
  //         fu-&gt;get_reply() &gt;&gt; followerAppendOK;
  //         };
  //       /* wrap Marshallable in a MarshallDeputy to send over RPC */
  //       MarshallDeputy md(cmd);
  //       Call_Async(proxy, AppendEntries, md, fuattr);
  //     }
  //   }
  // }


  // Initial implementation that helped understand how the calls work.
  shared_ptr&lt;IntEvent&gt;
    RaftCommo::SendString(parid_t par_id, siteid_t site_id, const string& msg, string* res) {
    auto proxies = rpc_par_proxies_[par_id];
    auto ev = Reactor::CreateSpEvent&lt;IntEvent&gt;();
    for (auto& p : proxies) {
      if (p.first == site_id) {
        RaftProxy* proxy = (RaftProxy*)p.second;
        FutureAttr fuattr;
        fuattr.callback = [res, ev](Future* fu) {
          fu-&gt;get_reply() &gt;&gt; *res;
          Log_info("Response mil gaya");
          ev-&gt;Set(1);
          };
        /* wrap Marshallable in a MarshallDeputy to send over RPC */
        Call_Async(proxy, HelloRpc, msg, fuattr);
        Log_info("Called Async");
      }
    }
    return ev;
  }


} // namespace janus
</PRE>
</PRE>
</BODY>
</HTML>
