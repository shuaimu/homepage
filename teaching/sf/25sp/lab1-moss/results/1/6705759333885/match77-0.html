<HTML>
<HEAD>
<TITLE>./github-lab1/dslabs-cpp-devu1997/src/deptran/raft/server.cc</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
./github-lab1/dslabs-cpp-devu1997/src/deptran/raft/server.cc<p><PRE>

#include "server.h"
// #include "paxos_worker.h"
#include "exec.h"
#include "frame.h"
#include "coordinator.h"
#include "../classic/tpc_command.h"

namespace janus {

RaftServer::RaftServer(Frame * frame) {
  // TODO: Remove after finishing
  Log::set_level(Log::DEBUG);
  Log_debug("Raft server is being created");

  frame_ = frame ;
  srand(time(0));
  lastHeartbeatTimer-&gt;start();
  /* Your code here for server initialization. Note that this function is 
     called in a different OS thread. Be careful about thread safety if 
     you want to initialize variables here. */
}

RaftServer::~RaftServer() {
  /* Your code here for server teardown */
  Log_debug("Raft server is being teardown");
}

void RaftServer::Setup() {
  /* Your code here for server setup. Due to the asynchronous nature of the 
     framework, this function could be called after a RPC handler is triggered. 
     Your code should be aware of that. This function is always called in the 
     same OS thread as the RPC handlers. */
  Log_debug("Raft server is being setup");
  mtx_.lock();
  lastHeartbeatTimer-&gt;start();
  mtx_.unlock();
  PeriodicRpcScheduler();
  Log_debug("Raft server setup is complete");
}

bool RaftServer::Start(shared_ptr&lt;Marshallable&gt; &cmd,
                       uint64_t *index,
                       uint64_t *term) {
  /* Your code here. This function can be called from another OS thread. */
  mtx_.lock();
  *term = currentTerm;
  isLeader = this-&gt;isLeader;
  if (isLeader) {
    // start agreement on cmd in a new log entry
    LogEntry logEntry = {
      currentTerm,
      cmd
    };
    logEntries.push_back(logEntry);
  }
  *index = getLastIndex();
  mtx_.unlock();
  Log_debug("Start: server: %d, current term: %d current index: %d leader: %d", site_id_, *term, *index, isLeader);
  return isLeader;
}

void RaftServer::GetState(bool *is_leader, uint64_t *term) {
  /* Your code here. This function can be called from another OS thread. */
  mtx_.lock();
  *is_leader = isLeader;
  *term = currentTerm;
  mtx_.unlock();
  Log_debug("GetState: server: %d, current term: %d leader: %d", site_id_, *term, *is_leader);
}

void RaftServer::PeriodicRpcScheduler() {
  Coroutine::CreateRun([this](){
    while(true) {
      mtx_.lock();
      bool_t isLeader = this-&gt;isLeader;
      mtx_.unlock();

      if (isLeader) {
        SendPendingEntries();
      } else {
        StartLeaderElection();
      }
    }
  });
  Coroutine::CreateRun([this](){
    while(true) {
      // mtx_.lock();
      // bool_t isLeader = this-&gt;isLeader;
      // mtx_.unlock();

      // if (isLeader) {
      //   SendPendingEntries();
      // }
      WriteCommittedEntriesToState();
      Coroutine::Sleep(10000);
    }
  });
}

void RaftServer::WriteCommittedEntriesToState() {
  mtx_.lock();
  for (int i=lastApplied+1; i&lt;=lastCommitIndex; i++) {
    LogEntry *logEntry = getLogEntryAtIndex(i);
    app_next_(*logEntry-&gt;cmd);
    Log_debug("Server: %d wrote log at index: %d to state", site_id_, i);
  }
  lastApplied = lastCommitIndex;
  mtx_.unlock();
}

void RaftServer::SendPendingEntries() {
  mtx_.lock();
  double elapsedTime = lastHeartbeatTimer-&gt;elapsed();
  mtx_.unlock();

  Log_debug("Leader: %d checking when last heartbeat was send", site_id_);
  if (!isFirstHearbeatOfLeader && elapsedTime &lt;= HEARTBEAT_INTERVAL_IN_SECONDS) {
    Coroutine::Sleep(10000);
    return;
  }

  isFirstHearbeatOfLeader = false;
  Log_debug("Leader: %d sending append entries", site_id_);

  mtx_.lock();
  uint64_t lastLogIndex = getLastIndex();
  uint64_t leaderCurrentTerm = currentTerm;
  uint64_t leaderLastCommitIndex = lastCommitIndex;
  lastHeartbeatTimer-&gt;start();
  mtx_.unlock();

  uint64_t successCounts = 1;
  uint64_t maxFollowerCurrentTerm = leaderCurrentTerm;
  for (int followerId=0; followerId&lt;5; followerId++) {
    if (site_id_ == followerId) {
      continue;
    }

    mtx_.lock();
    uint64_t nextIndexOfFollower = nextIndex[followerId];
    mtx_.unlock();

    // if (lastLogIndex &gt;= nextIndexOfFollower) {

    Coroutine::CreateRun([this, lastLogIndex, leaderCurrentTerm, leaderLastCommitIndex, followerId, &successCounts, &maxFollowerCurrentTerm](){
      while (true) {
        vector&lt;shared_ptr&lt;Marshallable&gt;&gt; commands;
        vector&lt;uint64_t&gt; termOfLogs;

        mtx_.lock();
        for (int i=nextIndex[followerId]; i&lt;=lastLogIndex; i++) {
          LogEntry *log = getLogEntryAtIndex(i);
          commands.push_back(log-&gt;cmd);
          termOfLogs.push_back(log-&gt;term);
        }
        int prevLogIndexOfFollower = nextIndex[followerId] - 1;
        LogEntry *prevLogEntryFollower = getLogEntryAtIndex(prevLogIndexOfFollower);
        uint64_t prevLogTermOfFollower = prevLogEntryFollower == NULL ? 0 : prevLogEntryFollower-&gt;term;
        mtx_.unlock();

        bool_t followerAppendOK = false;
        bool_t disconnected = false;
        uint64_t followerCurrentTerm = 0;
        AppendEntriesRpc(leaderCurrentTerm, leaderLastCommitIndex, followerId, prevLogIndexOfFollower, prevLogTermOfFollower, commands, termOfLogs, followerCurrentTerm, followerAppendOK);

        mtx_.lock();
        if (followerAppendOK) {
          nextIndex[followerId] = lastLogIndex + 1;
          matchIndex[followerId] = lastLogIndex;
          successCounts++;
          mtx_.unlock();
          break;
        }
        if (followerCurrentTerm &gt; currentTerm) {
          isLeader = false;
          maxFollowerCurrentTerm = max(maxFollowerCurrentTerm, followerCurrentTerm);
          mtx_.unlock();
          break;
        }
        if (followerCurrentTerm == 0 || nextIndex[followerId] == 1) {
          mtx_.unlock();
          break;
        }
        nextIndex[followerId] = nextIndex[followerId] &lt;= 10 ? 1 : nextIndex[followerId] - 10;
        Log_debug("Trying again with new next index %d", nextIndex[followerId]);
        mtx_.unlock();
      }
    });
    // } else {
    //   successCounts++;
    // }
  }
  Coroutine::Sleep(100000);

  mtx_.lock();
  currentTerm = maxFollowerCurrentTerm;
  if (successCounts &gt; 2) {
    lastCommitIndex = lastLogIndex;
  }
  mtx_.unlock();
}

void RaftServer::StartLeaderElection() {
  mtx_.lock();
  double elapsedTime = lastHeartbeatTimer-&gt;elapsed();
  mtx_.unlock();

  Log_debug("Follower: %d checking when last heartbeat was received", site_id_);
  if (elapsedTime &lt;= ELECTION_TIMEOUT_INTERVAL_IN_SECONDS + (((rand() * 1.0) / (RAND_MAX * 1.0)) * .5)) {
    Coroutine::Sleep(10000);
    return;
  }

  Log_debug("Candidate: %d starting election as no heartbeat from leader", site_id_);
  mtx_.lock();
  currentTerm = currentTerm + 1;
  votedFor = site_id_;

  uint64_t lastLogIndex = getLastIndex();
  uint64_t lastLogTerm = 0;
  if (logEntries.size() &gt; 0) {
    LogEntry lastLogEntry = logEntries.back();
    lastLogTerm = lastLogEntry.term;
  }

  uint64_t leaderCurrentTerm = currentTerm;
  uint64_t leaderLastCommitIndex = lastCommitIndex;
  mtx_.unlock();

  uint16_t votes = 1;
  uint64_t maxFollowerCurrentTerm = leaderCurrentTerm;
  for (int followerId=0; followerId&lt;5; followerId++) {
    if (site_id_ == followerId) {
      continue;
    }
    bool_t voteGranted = false;
    uint64_t followerCurrentTerm = 0;
    RequestVoteRpc(leaderCurrentTerm, leaderLastCommitIndex, followerId, lastLogIndex, lastLogTerm, followerCurrentTerm, voteGranted);
    
    if (voteGranted) {
      votes++;
    } else if (followerCurrentTerm &gt; leaderCurrentTerm) {
      maxFollowerCurrentTerm = max(maxFollowerCurrentTerm, followerCurrentTerm);
    }
  }
  
  mtx_.lock();
  if (votes &gt; 2) {
    isLeader = true;
    for (int followerId=0; followerId&lt;5; followerId++) {
      nextIndex[followerId] = lastLogIndex + 1;
    }
    Log_debug("Candidate: %d is elected as leader for term: %d", site_id_, currentTerm);
  } else {
    isLeader = false;
    currentTerm = maxFollowerCurrentTerm;
    lastHeartbeatTimer-&gt;start();
    backoffPower = backoffPower + (rand()/RAND_MAX) + 1;
    Log_debug("Candidate: %d lost election for term: %d", site_id_, currentTerm);
  }
  mtx_.unlock();
}

void RaftServer::SendHeartbeats() {
  mtx_.lock();
  double elapsedTime = lastHeartbeatTimer-&gt;elapsed();
  mtx_.unlock();

  Log_debug("Leader: %d checking when last heartbeat was send", site_id_);
  if (!isFirstHearbeatOfLeader && elapsedTime &lt;= HEARTBEAT_INTERVAL_IN_SECONDS) {
    Coroutine::Sleep(30000);
    return;
  }

  isFirstHearbeatOfLeader = false;
  Log_debug("Leader: %d sending heartbeat", site_id_);

  mtx_.lock();
  lastHeartbeatTimer-&gt;start();
  uint64_t leaderCurrentTerm = currentTerm;
  uint64_t leaderLastCommitIndex = lastCommitIndex;
  mtx_.unlock();

  uint64_t maxFollowerCurrentTerm = leaderCurrentTerm;
  for (int followerId=0; followerId&lt;5; followerId++) {
    if (site_id_ == followerId) {
      continue;
    }

    mtx_.lock();
    int prevLogIndexOfFollower = nextIndex[followerId] - 1;
    LogEntry *prevLogEntryFollower = getLogEntryAtIndex(prevLogIndexOfFollower);
    uint64_t prevLogTermOfFollower = prevLogEntryFollower == NULL ? 0 : prevLogEntryFollower-&gt;term;
    mtx_.unlock();

    uint64_t followerCurrentTerm = 0;
    bool_t followerAppendOK = false;
    EmptyAppendEntriesRpc(leaderCurrentTerm, leaderLastCommitIndex, followerId, prevLogIndexOfFollower, prevLogTermOfFollower, followerCurrentTerm, followerAppendOK);

    mtx_.lock();
    if (followerCurrentTerm &gt; leaderCurrentTerm) {
      maxFollowerCurrentTerm = max(maxFollowerCurrentTerm, followerCurrentTerm);
      isLeader = false;
      mtx_.unlock();
      break;
    } else if (!followerAppendOK && followerCurrentTerm != 0) {
      nextIndex[followerId] = nextIndex[followerId] &lt;= 10 ? 1 : nextIndex[followerId] - 10;
      mtx_.unlock();
    } else {
      mtx_.unlock();
    }
  }

  mtx_.lock();
  if (!isLeader) {
    Log_debug("Leader: %d stepped down to follower", site_id_);
    lastHeartbeatTimer-&gt;start();
    currentTerm = maxFollowerCurrentTerm;
  } else {
    Log_debug("Heartbeats were send successfully");
  }
  mtx_.unlock();

}

void RaftServer::RequestVoteRpc(uint64_t currentTerm, uint64_t lastCommitIndex, uint16_t followerId, uint64_t lastLogIndex, uint64_t lastLogTerm, uint64_t &followerCurrentTerm, bool_t &voteGranted) {
  Log_debug("Candidate: %d sending RequestVoteRpc to follower %d", site_id_, followerId);
  auto event = commo()-&gt;SendRequestVote(0, followerId, currentTerm, site_id_, lastLogIndex, lastLogTerm, &followerCurrentTerm, &voteGranted);
  event-&gt;Wait(1000000); //timeout after 1000000us=1s
  if (event-&gt;status_ == Event::TIMEOUT) {
    Log_info("Election timed out for candidate: %d from follower: %d", site_id_, followerId);
  } else {
    Log_debug("Election response for candidate: %d from follower: %d is: [currentTerm - %d, voteGranted - %d]", site_id_, followerId, followerCurrentTerm, voteGranted); 
  }
}

void RaftServer::EmptyAppendEntriesRpc(uint64_t currentTerm, uint64_t lastCommitIndex, uint16_t followerId, uint64_t lastLogIndex, uint64_t lastLogTerm, uint64_t &followerCurrentTerm, bool_t &followerAppendOK) {
  Log_debug("Leader: %d sending EmptyAppendEntriesRpc to follower %d with last commit index: %d", site_id_, followerId, lastCommitIndex);
<A NAME="0"></A><FONT color = #FF0000><A HREF="match77-1.html#0" TARGET="1"><IMG SRC="../../../bitmaps/tm_0_1.gif" ALT="other" BORDER="0" ALIGN=left></A>

  auto event = commo()-&gt;SendEmptyAppendEntries(0, followerId, currentTerm, site_id_, lastLogIndex, lastLogTerm, lastCommitIndex, &followerCurrentTerm, &followerAppendOK);
  event-&gt;Wait(1000000); //timeout after 1000000us=1s
  if (event-&gt;status_ == Event::TIMEOUT) {
</FONT>    Log_info("EmptyAppendEntries timed out for follower: %d from leader: %d", followerId, site_id_);
  } else {
    Log_debug("EmptyAppendEntries rpc response for follower: %d from leader: %d is: [currentTerm - %d, followerAppendOK - %d]", followerId, site_id_, followerCurrentTerm, followerAppendOK); 
  }
}

<A NAME="1"></A><FONT color = #00FF00><A HREF="match77-1.html#1" TARGET="1"><IMG SRC="../../../bitmaps/tm_1_1.gif" ALT="other" BORDER="0" ALIGN=left></A>

void RaftServer::AppendEntriesRpc(uint64_t currentTerm, uint64_t lastCommitIndex, uint16_t followerId, uint64_t lastLogIndex, uint64_t lastLogTerm, vector&lt;shared_ptr&lt;Marshallable&gt;&gt; commands, vector&lt;uint64_t&gt; termOfLogs, uint64_t &followerCurrentTerm, bool_t &followerAppendOK) {
</FONT>  Log_debug("Leader: %d sending AppendEntriesRpc to follower %d with last commit index: %d", site_id_, followerId, lastCommitIndex);
<A NAME="2"></A><FONT color = #0000FF><A HREF="match77-1.html#2" TARGET="1"><IMG SRC="../../../bitmaps/tm_2_1.gif" ALT="other" BORDER="0" ALIGN=left></A>

  auto event = commo()-&gt;SendAppendEntries(0, followerId, currentTerm, site_id_, lastLogIndex, lastLogTerm, lastCommitIndex, commands, termOfLogs, &followerCurrentTerm, &followerAppendOK);
  event-&gt;Wait(1000000); //timeout after 1000000us=1s
  if (event-&gt;status_ == Event::TIMEOUT) {
</FONT>    Log_info("AppendEntriesRpc timed out for follower: %d", followerId);
  } else {
    Log_debug("AppendEntriesRpc rpc response for follower: %d is: [currentTerm - %d, followerAppendOK - %d]", followerId, followerCurrentTerm, followerAppendOK); 
  }
}

void RaftServer::SyncRpcExample() {
  /* This is an example of synchronous RPC using coroutine; feel free to 
     modify this function to dispatch/receive your own messages. 
     You can refer to the other function examples in commo.h/cc on how 
     to send/recv a Marshallable object over RPC. */
  Coroutine::CreateRun([this](){
    string res;
    auto event = commo()-&gt;SendString(0, /* partition id is always 0 for lab1 */
                                     0, "hello", &res);
    event-&gt;Wait(1000000); //timeout after 1000000us=1s
    if (event-&gt;status_ == Event::TIMEOUT) {
      Log_info("timeout happens");
    } else {
      Log_info("rpc response is: %s", res.c_str()); 
    }
  });
}

/* Do not modify any code below here */

void RaftServer::Disconnect(const bool disconnect) {
  std::lock_guard&lt;std::recursive_mutex&gt; lock(mtx_);
  verify(disconnected_ != disconnect);
  // global map of rpc_par_proxies_ values accessed by partition then by site
  static map&lt;parid_t, map&lt;siteid_t, map&lt;siteid_t, vector&lt;SiteProxyPair&gt;&gt;&gt;&gt; _proxies{};
  if (_proxies.find(partition_id_) == _proxies.end()) {
    _proxies[partition_id_] = {};
  }
  RaftCommo *c = (RaftCommo*) commo();
  if (disconnect) {
    verify(_proxies[partition_id_][loc_id_].size() == 0);
    verify(c-&gt;rpc_par_proxies_.size() &gt; 0);
    auto sz = c-&gt;rpc_par_proxies_.size();
    _proxies[partition_id_][loc_id_].insert(c-&gt;rpc_par_proxies_.begin(), c-&gt;rpc_par_proxies_.end());
    c-&gt;rpc_par_proxies_ = {};
    verify(_proxies[partition_id_][loc_id_].size() == sz);
    verify(c-&gt;rpc_par_proxies_.size() == 0);
  } else {
    verify(_proxies[partition_id_][loc_id_].size() &gt; 0);
    auto sz = _proxies[partition_id_][loc_id_].size();
    c-&gt;rpc_par_proxies_ = {};
    c-&gt;rpc_par_proxies_.insert(_proxies[partition_id_][loc_id_].begin(), _proxies[partition_id_][loc_id_].end());
    _proxies[partition_id_][loc_id_] = {};
    verify(_proxies[partition_id_][loc_id_].size() == 0);
    verify(c-&gt;rpc_par_proxies_.size() == sz);
  }
  disconnected_ = disconnect;
}

bool RaftServer::IsDisconnected() {
  return disconnected_;
}

} // namespace janus
</PRE>
</PRE>
</BODY>
</HTML>
