<HTML>
<HEAD>
<TITLE>/root/ds-labs-ta/github-lab3/shuai-teaching/dslabs-cpp-PranavDani/src/shardmaster/service.h</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
/root/ds-labs-ta/github-lab3/shuai-teaching/dslabs-cpp-Sirneij/src/shardmaster/service.h<p><PRE>

#pragma once

#include "../deptran/__dep__.h"
#include "../deptran/raft/server.h"

class ShardConfig
{
public:
  int32_t number{0};
  map&lt;uint32_t, uint32_t&gt; shard_group_map_{{1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}, {6, 0}, {7, 0}, {8, 0}, {9, 0}, {10, 0}};
  map&lt;uint32_t, vector&lt;uint32_t&gt;&gt; group_servers_map_{};
  // Lab Shard: you can add functions to this class but do not add/remove member variables
};

inline Marshal &operator&gt;&gt;(Marshal &m, ShardConfig &rhs)
{
  m &gt;&gt; rhs.number &gt;&gt; rhs.shard_group_map_ &gt;&gt; rhs.group_servers_map_;
  return m;
}

<A NAME="2"></A><FONT color = #0000FF><A HREF="match136-0.html#2" TARGET="0"><IMG SRC="../../../bitmaps/tm_2_4.gif" ALT="other" BORDER="0" ALIGN=left></A>

inline Marshal &operator&lt;&lt;(Marshal &m, const ShardConfig &rhs)
{
  m &lt;&lt; rhs.number &lt;&lt; rhs.shard_group_map_ &lt;&lt; rhs.group_servers_map_;
  return m;
}

#include "shardmaster_rpc.h"

namespace janus
{
  class ShardMasterCommand : public Marshallable
</FONT>  {
  public:
    static uint64_t global_cmd_id_counter;
    uint64_t cmd_id; // Unique command identifier
    // Command type represented as a string
    std::string type;

    // Specific fields for each command type
    std::map&lt;uint32_t, std::vector&lt;uint32_t&gt;&gt; gid_server_map; // For Join
    std::vector&lt;uint32_t&gt; gids;                               // For Leave
    int32_t shard;                                            // For Move
    uint32_t gid;                                             // For Move
    int32_t config_no;                                        // For Query

    // Constructors for different command types
    ShardMasterCommand() : Marshallable(MarshallDeputy::CMD_SHARD_MASTER)
    {
      cmd_id = global_cmd_id_counter++;
    }

    // Serialization
    Marshal &ToMarshal(Marshal &m) const override
    {
      m &lt;&lt; cmd_id;
      m &lt;&lt; type;
      if (type == "Join")
      {
        m &lt;&lt; gid_server_map;
      }
      else if (type == "Leave")
      {
        m &lt;&lt; gids;
      }
      else if (type == "Move")
      {
        m &lt;&lt; shard &lt;&lt; gid;
      }
      else if (type == "Query")
      {
        m &lt;&lt; config_no;
      }
      return m;
    }

    Marshal &FromMarshal(Marshal &m) override
    {
      m &gt;&gt; cmd_id;
      m &gt;&gt; type;
      if (type == "Join")
      {
        m &gt;&gt; gid_server_map;
      }
      else if (type == "Leave")
      {
        m &gt;&gt; gids;
      }
      else if (type == "Move")
      {
        m &gt;&gt; shard &gt;&gt; gid;
      }
      else if (type == "Query")
      {
<A NAME="1"></A><FONT color = #00FF00><A HREF="match136-0.html#1" TARGET="0"><IMG SRC="../../../bitmaps/tm_1_5.gif" ALT="other" BORDER="0" ALIGN=left></A>

        m &gt;&gt; config_no;
      }
      return m;
    }
  };

  // class TxLogServer;
  // class KvServer;
  class ShardMasterClient;
  class ShardMasterServiceImpl : public ShardMasterService
  {
  public:
    shared_ptr&lt;TxLogServer&gt; sp_log_svr_{};
    const uint64_t SM_TIMEOUT = 10000000; // 10s
    map&lt;uint32_t, ShardConfig&gt; configs_{};
</FONT>    // add your own variables here if needed
    // Lock for the shard master. Used to ensure thread safety.
    std::recursive_mutex shard_master_mutex_;
    // This is the latest committed command. Used to ensure idempotence.
    std::set&lt;uint64_t&gt; committed_cmds_;
    const int NShards = 10; // Assuming the number of shards is a constant

    // add your own functions here if needed
    void RebalanceShards(ShardConfig &config);
    uint32_t FindGroupNeedingShards(const std::map&lt;uint32_t, int&gt; &currentShardCount, int shardsPerGroup, int extraShards);
<A NAME="0"></A><FONT color = #FF0000><A HREF="match136-0.html#0" TARGET="0"><IMG SRC="../../../bitmaps/tm_0_5.gif" ALT="other" BORDER="0" ALIGN=left></A>

    void rebalanceShards(ShardConfig* config);

    // stringify the config for debugging
    std::string ConfigToString(const ShardConfig &config);

    // do not change anything below
    RaftServer &GetRaftServer()
    {
      auto p = dynamic_pointer_cast&lt;RaftServer&gt;(sp_log_svr_);
      verify(p != nullptr);
      return *p;
    }
    ShardMasterServiceImpl() {}
    virtual void Join(const std::map&lt;uint32_t, std::vector&lt;uint32_t&gt;&gt; &gid_server_map, uint32_t *ret, rrr::DeferredReply *defer) override;
</FONT>    virtual void Leave(const std::vector&lt;uint32_t&gt; &gids, uint32_t *ret, rrr::DeferredReply *defer) override;
    virtual void Move(const int32_t &shard, const uint32_t &gid, uint32_t *ret, rrr::DeferredReply *defer) override;
    virtual void Query(const int32_t &config_no, uint32_t *ret, ShardConfig *config, rrr::DeferredReply *defer) override;
    void OnNextCommand(Marshallable &m);
    shared_ptr&lt;ShardMasterClient&gt; CreateClient();
  };

} // namespace janus
</PRE>
</PRE>
</BODY>
</HTML>
