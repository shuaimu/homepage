<HTML>
<HEAD>
<TITLE>/root/ds-labs-ta/github-lab3/shuai-teaching/dslabs-cpp-smeshah/src/shardkv/client.cc</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
/root/ds-labs-ta/github-lab3/shuai-teaching/dslabs-cpp-smeshah/src/shardkv/client.cc<p><PRE>


#include "client.h"
#include "server.h"

namespace janus {

int ShardKvClient::Op(function&lt;int(uint32_t*)&gt; func) {
  Log_info("Next op called in client");
  uint64_t t1 = Time::now();
  while (true) {
    uint64_t t2 = Time::now();
    if (t2 - t1 &gt; 10000000) {
      return KV_TIMEOUT;
    }
    uint32_t ret = 0;
    int r1; 
    r1 = func(&ret);
    if (leader_idx_ &gt; server_start_idx + 5){
        leader_idx_ = server_start_idx;
    }
    // Log_info("leader idx is %d r1 is %d ret is %d", leader_idx_, r1, ret);
<A NAME="0"></A><FONT color = #FF0000><A HREF="match232-1.html#0" TARGET="1"><IMG SRC="../../../bitmaps/tm_0_8.gif" ALT="other" BORDER="0" ALIGN=left></A>

    if (r1 == ETIMEDOUT || ret == KV_TIMEOUT) {
      leader_idx_ = (leader_idx_+1);
      return KV_TIMEOUT;
    }
    if (ret == KV_SUCCESS) {
      return KV_SUCCESS;
    }
    if (ret == KV_NOTLEADER) {
      leader_idx_ = (leader_idx_+1);
    }

  }

}

int ShardKvClient::Put(const string& k, const string& v) {    
  auto p = (ShardMasterProxy*)commo_-&gt;rpc_proxies_.at(0);
</FONT>  uint32_t config_no = -1;
  uint32_t ret = -1;
  ShardConfig shardConfig;
  p-&gt;Query(config_no, &ret, &shardConfig);
  int key = Key2Shard(k);
  int gid = 0;
  for (const auto& shardGroupPair : shardConfig.shard_group_map_) {
    if (shardGroupPair.first == key){
      gid = shardGroupPair.second;
    }
  }
    for (const auto& groupServersPair : shardConfig.group_servers_map_) {
      if (groupServersPair.first == gid){
        for (const auto& server : groupServersPair.second) {
            leader_idx_ = server;
            server_start_idx = server;
            break;
        }
      }
  }
  return Op([&](uint32_t* r)-&gt;int{
    return Proxy(leader_idx_).Put(GetNextOpId(), k, v, r);
  });
}

ShardKvProxy& ShardKvClient::Proxy(siteid_t site_id) {

  verify(commo_);
  ShardKvProxy *myProxy;
  myProxy = (ShardKvProxy*)commo_-&gt;rpc_proxies_.at(site_id); 
  return *myProxy; 
}

int ShardKvClient::Append(const string& k, const string& v) {
  auto p = (ShardMasterProxy*)commo_-&gt;rpc_proxies_.at(0);
  uint32_t config_no = -1;
  uint32_t ret = -1;
  ShardConfig shardConfig;
  p-&gt;Query(config_no, &ret, &shardConfig);
  int key = Key2Shard(k);
  int gid = 0;
  for (const auto& shardGroupPair : shardConfig.shard_group_map_) {
    if (shardGroupPair.first == key){
      gid = shardGroupPair.second;
    }
  }
    for (const auto& groupServersPair : shardConfig.group_servers_map_) {
      if (groupServersPair.first == gid){
        for (const auto& server : groupServersPair.second) {
            leader_idx_ = server;
            server_start_idx = server;
            break;
        }
      }
  }
  return Op([&](uint32_t* r)-&gt;int{
<A NAME="1"></A><FONT color = #00FF00><A HREF="match232-1.html#1" TARGET="1"><IMG SRC="../../../bitmaps/tm_1_4.gif" ALT="other" BORDER="0" ALIGN=left></A>

    return Proxy(leader_idx_).Append(GetNextOpId(), k, v, r);
  });
}

int ShardKvClient::Get(const string& k, string* v) {
  auto p = (ShardMasterProxy*)commo_-&gt;rpc_proxies_.at(0);
</FONT>  uint32_t config_no = -1;
  uint32_t ret = -1;
  ShardConfig shardConfig;
  p-&gt;Query(config_no, &ret, &shardConfig);
  int key = Key2Shard(k);
  int gid = 0;
  for (const auto& shardGroupPair : shardConfig.shard_group_map_) {
    if (shardGroupPair.first == key){
      gid = shardGroupPair.second;
    }
  }
    for (const auto& groupServersPair : shardConfig.group_servers_map_) {
      if (groupServersPair.first == gid){
        for (const auto& server : groupServersPair.second) {
            leader_idx_ = server;
            server_start_idx = server;
            break;
        }
      }
  }
  return Op([&](uint32_t* r)-&gt;int{
    return Proxy(leader_idx_).Get(GetNextOpId(), k, r, v);
  });
}

} // namesapce janus;</PRE>
</PRE>
</BODY>
</HTML>
